{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2022金三银四前端面试笔记/","result":{"data":{"site":{"siteMetadata":{"title":"shanejix","description":"learner && coder"}},"allMarkdownRemark":{"edges":[{"node":{"id":"9dd4013c-c308-552c-bd2c-04f0cd996599","timeToRead":5}},{"node":{"id":"d29bf37d-75f0-501e-92b1-42c06cdbcd7b","timeToRead":3}},{"node":{"id":"89619e78-eeef-5342-b7fe-7626ee925f57","timeToRead":9}},{"node":{"id":"cb3a4052-202e-5a46-bf15-4e9b30e34ebf","timeToRead":3}},{"node":{"id":"45c6b07a-fc6a-5800-9907-86a94c1f4ace","timeToRead":2}},{"node":{"id":"db38bc53-9935-56f0-a9e2-0be373990d78","timeToRead":3}},{"node":{"id":"1dcfd849-d044-5c73-b31a-5fd30393f430","timeToRead":14}},{"node":{"id":"7b38ed3c-4032-581a-aab4-bda6dcb8fa78","timeToRead":15}},{"node":{"id":"d15e9143-f799-527d-b71d-2b8fc195817c","timeToRead":12}},{"node":{"id":"ba521381-a518-5686-a682-0ada55a7dd73","timeToRead":4}},{"node":{"id":"ba58ecad-907f-5ad2-bc26-9167d7607dcc","timeToRead":12}},{"node":{"id":"08b71346-abf3-5649-84f5-2f8ae4f48c6a","timeToRead":3}},{"node":{"id":"da55e002-3a8a-5af2-929e-4de7e3a8d314","timeToRead":4}},{"node":{"id":"4e56b6de-c0ca-572e-9f9d-e769592aa49b","timeToRead":2}},{"node":{"id":"af002700-632d-547f-82b9-f31919d4f03e","timeToRead":1}},{"node":{"id":"7b6d671f-8de2-5511-91e9-0797db813dc7","timeToRead":1}},{"node":{"id":"ad4fad45-b734-560c-8324-a9708e1e04c4","timeToRead":1}},{"node":{"id":"ef84ef13-dac8-5cfa-ac69-d0ea44f677f1","timeToRead":2}},{"node":{"id":"69026b7f-ca1c-5eea-8f61-76972396800c","timeToRead":2}},{"node":{"id":"52b13183-db66-5637-bc21-c828b8dabddd","timeToRead":8}},{"node":{"id":"14bde951-d8e7-5045-84f7-dd9479cfafc3","timeToRead":35}},{"node":{"id":"aa4d72c6-d675-52e4-a55b-b07237ed0e1a","timeToRead":2}},{"node":{"id":"eb631c0f-69a5-5ca8-b3c7-1baaed014eea","timeToRead":1}},{"node":{"id":"684d2035-e385-577d-bb53-f7bfca2caa0d","timeToRead":18}},{"node":{"id":"a40d34f8-b202-5f5b-8c33-19c7c163bbce","timeToRead":5}},{"node":{"id":"afc44728-7e4f-5ce3-bf62-373400a8a46a","timeToRead":12}},{"node":{"id":"ca3cc4cf-0ddf-5fb3-a58d-2354b2f0a10e","timeToRead":5}},{"node":{"id":"fe7fd5be-04af-5d1a-b969-f8f4de7db655","timeToRead":1}},{"node":{"id":"fb3bc99d-cf2f-5fbd-981d-1d701815f87b","timeToRead":66}},{"node":{"id":"4de1fb79-73c7-5593-adc3-427351c465e9","timeToRead":101}},{"node":{"id":"9a102758-e412-5f31-8753-54534e8fdb15","timeToRead":1}},{"node":{"id":"a07217e5-4cbe-54e4-9566-2a0df732a1a4","timeToRead":1}},{"node":{"id":"c8a73065-3214-5616-93f3-0df2a119e91d","timeToRead":1}}]},"markdownRemark":{"id":"fb3bc99d-cf2f-5fbd-981d-1d701815f87b","excerpt":"同步链接: https://www.shanejix.com/posts/2022 金三银四前端面试笔记/ 202…","html":"<blockquote>\n<p>同步链接: <a href=\"https://www.shanejix.com/posts/2022%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/\">https://www.shanejix.com/posts/2022 金三银四前端面试笔记/</a></p>\n</blockquote>\n<p>2022 金三银四 真可谓 铜三铁四 ！伴随着京东、字节、蚂蚁等头部互联网公司员工被大量被优化，我也一把鼻涕一把泪的加入了内卷大军。</p>\n<p>下面的主要内容是前端基础知识的梳理（大纲式笔记），具体内容部分有链接可以跳转后深入学习。这部分内容是结合自己的面试经历和市场上大部的反馈整理出的笔记。在此记录一下，方便后续复盘。</p>\n<p>特别说明：</p>\n<p>如果你正在找工作或者计划跳槽，可以参考单别照抄，强烈建议您手把手整理自己的知识体系，完善自己的思维，形成自己的文档</p>\n<p>➕：代表综合自己所有面试被问到的频率</p>\n<p>🔥：市场反馈的热度</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/377147/1649745952498-0ded8dd1-5196-42fc-aca4-a7f0f47c8606.png#clientId=u0d34be0f-d92c-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=572&#x26;id=u1ca16827&#x26;name=image.png&#x26;originHeight=715&#x26;originWidth=806&#x26;originalType=binary&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=48181&#x26;status=done&#x26;style=none&#x26;taskId=u67efd100-a7f8-43b8-9db7-6d615333b2e&#x26;title=&#x26;width=644.8\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/377147/1649746113484-7e57dade-5e89-427a-b258-6471d6ccf57e.png#clientId=u0d34be0f-d92c-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=drop&#x26;id=u91c38cc6&#x26;name=%5B2022%5DShaneJix%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.png&#x26;originHeight=4733&#x26;originWidth=3580&#x26;originalType=binary&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=2277665&#x26;status=done&#x26;style=none&#x26;taskId=u1d4610cf-d570-48d5-8006-a31ffb0b132&#x26;title=\" alt=\"[2022]ShaneJix前端面试笔记.png\"></p>\n<p>正文如下</p>\n<h2>零、面试相关</h2>\n<ul>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e9%9d%a2%e8%af%95%e9%98%b6%e6%ae%b5-%f0%9f%94%a5%f0%9f%94%a5\">面试阶段</a></p>\n<ul>\n<li>一面</li>\n<li>二面</li>\n<li>hr 面</li>\n</ul>\n</li>\n<li>\n<p>➕➕➕<a href=\"https://interview.shanejix.com/#/?id=%e4%b8%aa%e4%ba%ba%e4%bb%8b%e7%bb%8d-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">个人介绍 🔥🔥🔥</a></p>\n<ul>\n<li>面试官你好，我叫 xx，19 年毕业，目前有近 3 年的工作经验</li>\n<li>在技术方面对 react 比较熟悉，也能写点 typescript；</li>\n<li>在上一家公司主要负责 xx 平台官网的建设重构以及维护，也会进行基础设计的建设和通用打包脚本的编写和维护，也参与了物料平台的的设计以及 c 项目的初始化等工作</li>\n<li>平时喜欢从共工作中总结问题并得出一些通用的解决方案；常年混迹于 github，参与过大型开源项目并且贡献过 pr</li>\n</ul>\n</li>\n</ul>\n<h2>壹、HTML 相关</h2>\n<ul>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=html%e8%af%ad%e4%b9%89%e5%8c%96\">HTML 语义化</a></p>\n<ul>\n<li>是什么</li>\n<li>用合适的标签描述清晰的结构和内容</li>\n<li>为什么（作用）</li>\n<li>让开发者和机器更容易理解，便于维护</li>\n<li>让爬虫更容易爬取，有利于 seo</li>\n<li>怎么做</li>\n<li>框架集成（next 等</li>\n<li>三方库（seo</li>\n<li>\n<p>自己怎么写</p>\n<ul>\n<li>lighthouse</li>\n<li>语义化标签</li>\n<li>header</li>\n<li>footer</li>\n<li>不用非语义化标签</li>\n<li>div</li>\n<li>span</li>\n<li>sitemap</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>贰、CSS 相关</h2>\n<ul>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=bfc-%e7%9a%84%e5%bd%a2%e6%88%90%e5%92%8c%e4%bd%9c%e7%94%a8-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">BFC 的形成和作用 🔥🔥🔥</a></p>\n<ul>\n<li>是什么</li>\n<li>块级格式上下文</li>\n<li>只有块级盒子参与的独立独立渲染区域</li>\n<li>规定了内部块级盒子如何布局且与区域外部无关</li>\n<li>触发</li>\n<li>跟元素（html 元素）</li>\n<li>float</li>\n<li>overflow（不为 visible）</li>\n<li>position（不为 relative 和 static）</li>\n<li>\n<p>display</p>\n<ul>\n<li>inline-block</li>\n<li>flex</li>\n<li>grid</li>\n<li>table</li>\n</ul>\n</li>\n<li>作用</li>\n<li>修复浮动元素造成的高度塌陷问题</li>\n<li>防止 margin 重叠</li>\n<li>实现灵活健壮的自适应布局</li>\n<li>解析</li>\n<li>触发 BFC 的条件，创建 BFC</li>\n<li>在同一个 BFC 中，相邻块级盒子的垂直外边距会合并</li>\n<li>在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到包含块的左边缘</li>\n<li>深入</li>\n<li>\n<p>盒模型</p>\n<ul>\n<li>描述了一个由元素生成的矩形盒子<img src=\"https://cdn.nlark.com/yuque/0/2022/png/377147/1649744054279-9954a5d1-b855-4cb3-a831-51218dd6d55e.png#clientId=ubfed43c7-cbb4-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=ubc5c2492&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=340&#x26;originWidth=455&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=18922&#x26;status=done&#x26;style=none&#x26;taskId=ue86906da-b5ea-4fcd-9163-e6bba08e572&#x26;title=#crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;id=Vxrli&#x26;originHeight=340&#x26;originWidth=455&#x26;originalType=binary&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;status=done&#x26;style=none&#x26;title=\" alt=\"image.png\"></li>\n</ul>\n</li>\n<li>\n<p>视觉格式化模型</p>\n<ul>\n<li>决定盒子的大小、位置以及属性（例如颜色、背景、边框尺寸等等）</li>\n<li>包含块</li>\n<li>大部分情况下，包含块是一个由元素最近的祖先块容器的内容区域（content area）确定的矩形区域，</li>\n<li>包含块本身不是盒子，是一个矩形区域</li>\n<li>元素的大小，位置，及偏移等布局信息根据包含块的尺寸进行计算</li>\n<li>正常流</li>\n<li>正常流是浏览器的默认布局方式</li>\n<li>在正常流中的盒子，属于 BFC，IFC，或其他格式化上下文之一</li>\n<li>格式化上下文</li>\n<li>块级格式化上下文（BFC，block formatting context）</li>\n<li>内联格式化上下文（IFC，inline formatting context）</li>\n<li>弹性格式化上下文（FFC，flex formatting context），在 CSS3 中定义</li>\n<li>栅格格式化上下文（GFC，grid formatting context），在 CSS3 中定义</li>\n<li>独立格式化上下文</li>\n<li>一个盒子要么建立一个新的独立格式化上下文，要么延续其包含块的格式化上下文</li>\n<li>除了特殊说明，建立新的格式化上下文就是在建立一个独立格式化上下文</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e8%b0%88%e8%b0%88-css-%e9%a2%84%e5%a4%84%e7%90%86%e5%99%a8-%f0%9f%94%a5%f0%9f%94%a5\">谈谈 CSS 预处理器 🔥🔥</a></p>\n<ul>\n<li>是什么？为什么？</li>\n<li>CSS 本身不属于可编程语言，当前端项目逐渐庞大之后 CSS 的维护也愈加困难</li>\n<li>CSS 预处理器所做的本质上是为 CSS 增加一些可编程的特性，通过变量、嵌套、简单的程序逻辑、计算、函数等特性，通过工程化的手段让 CSS 更易维护，提升开发效率</li>\n<li>那些预处理器？</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=postcss\">PostCSS</a></p>\n<ul>\n<li>特点</li>\n<li>本体功能比较单一</li>\n<li>把 CSS 解析成 AST，插件化增强功能</li>\n<li>功能</li>\n<li><a href=\"https://github.com/postcss/autoprefixer\">Autoprefixer</a> 为 CSS 中的属性添加浏览器特定的前缀</li>\n<li><a href=\"https://github.com/csstools/postcss-preset-env\">postcss-preset-env</a> 根据 browserslist 指定的目标浏览器将一些 CSS 的新特性转换为目标浏览器所支持的语法</li>\n<li><a href=\"https://github.com/cssnano/cssnano\">cssnano</a> 提供 CSS 压缩功能</li>\n<li><a href=\"https://github.com/postcss/postcss-nested\">postcss-nested</a> 提供 CSS 嵌套功能</li>\n<li><a href=\"https://github.com/evrone/postcss-px-to-viewport\">postcss-px-to-viewport</a> 提供 px 转 vw 功能</li>\n<li><a href=\"https://github.com/postcss/postcss-custom-properties\">postcss-custom-properties</a> 支持 CSS 的自定义属性</li>\n<li>优点</li>\n<li>插件系统完善，扩展性强。</li>\n<li>配合插件功能齐全。</li>\n<li>生态优秀。</li>\n<li>缺点</li>\n<li>配置相对复杂</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=sass\">Sass</a>、<a href=\"https://interview.shanejix.com/#/?id=less\">Less</a></p>\n<ul>\n<li>特点</li>\n<li>完全兼容 CSS 语法</li>\n<li>less 浏览器端直接使用。</li>\n<li>功能</li>\n<li>变量、嵌套、混合、操作符、自定义函数等可编程能力</li>\n<li>优点</li>\n<li>使用广泛。</li>\n<li>功能支持完善。</li>\n<li>可编程能力强。</li>\n<li>缺点</li>\n<li>CSS 的复杂度不可控。</li>\n<li>node-sass 国内安装不易（非 Sass 本身的缺点，dart-sass 可代替）。</li>\n<li>less 不支持自定义函数（可通过 mixins 实现简单逻辑）</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=stylus\">Stylus</a></p>\n<ul>\n<li>与 less sass 类似</li>\n<li>最大的特点就是简洁（冒号、分号、逗号和括号都是可选项）</li>\n</ul>\n</li>\n<li>扩展</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=css-modules\">CSS Modules</a></p>\n<ul>\n<li>特点</li>\n<li>与预处理器不同，不是可编程化的 CSS</li>\n<li>CSS 文件加入了作用域和模块依赖</li>\n<li>作用（优点）</li>\n<li>解决 CSS 全局污染的痛点</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=css-in-js\">CSS-in-JS</a></p>\n<ul>\n<li>特点</li>\n<li>在 JavaScript 里写 CSS 的方式</li>\n<li>优点</li>\n<li>JS 的优势可实现非常灵活的可扩展的样式</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=tailwind-%e5%92%8c-utility-first-css\">Tailwind 和 Utility-first CSS</a></p>\n<ul>\n<li>特点</li>\n<li>功能类优先（Utility-first CSS）的理念</li>\n<li>优点</li>\n<li>不用考虑 class 的命名</li>\n<li>CSS 文件大小增长可控，通过 purge 可生成非常小的 CSS 文件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=%e6%b0%b4%e5%b9%b3%e5%9e%82%e7%9b%b4%e5%b1%85%e4%b8%ad%e6%96%b9%e6%a1%88-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">水平垂直居中方案 🔥🔥🔥</a></p>\n<ul>\n<li>flex</li>\n<li>grid</li>\n<li>相对定位</li>\n<li>transform:translate</li>\n<li>calc</li>\n<li>绝对定位</li>\n<li>transform:translate</li>\n<li>calc</li>\n<li>\n<p>margin</p>\n<ul>\n<li>left,right</li>\n<li>auto</li>\n</ul>\n</li>\n<li>表格布局</li>\n<li>table-cell</li>\n<li>line-height</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=%e7%a7%bb%e5%8a%a8%e7%ab%af%e8%87%aa%e9%80%82%e5%ba%94%e7%9a%84%e5%b8%b8%e8%a7%81%e6%89%8b%e6%ae%b5-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">移动端自适应的常见手段 🔥🔥🔥</a></p>\n<ul>\n<li>痛点（为什么）</li>\n<li>使不同的终端设备都拥有基本一致的视觉效果和交互体验</li>\n<li>适配方案</li>\n<li>视口元信息配置</li>\n<li>\n<p>响应式布局</p>\n<ul>\n<li>flex</li>\n<li>grid</li>\n</ul>\n</li>\n<li>\n<p>相对单位</p>\n<ul>\n<li>vw、vh</li>\n<li>rem</li>\n</ul>\n</li>\n<li>媒体查询</li>\n<li>响应式图片</li>\n<li>安全区域适配</li>\n</ul>\n</li>\n<li>\n<p>➕css 清除浮动</p>\n<ul>\n<li>clear:both/left/right</li>\n<li>触发 bfc</li>\n<li>让父级元素跟着浮动</li>\n</ul>\n</li>\n<li>\n<p>➕ 旋转盒子</p>\n<ul>\n<li>animation + transform:rotate</li>\n</ul>\n</li>\n<li>\n<p>➕ 单行/单行文本溢出省略</p>\n<ul>\n<li>单行</li>\n<li>overflow:hidden</li>\n<li>white-space:nowrap</li>\n<li>text-overflow: ellipsis</li>\n<li>多行</li>\n<li>伪元素+ 绝对定位</li>\n<li>clamp 属性</li>\n</ul>\n</li>\n<li>\n<p>➕➕ 两栏布局左侧自适应、三栏布局中间自适应</p>\n<ul>\n<li>两栏</li>\n<li>float:left ;margin-left ;BFC</li>\n<li>display:flex;flex:1;</li>\n<li>三栏</li>\n<li>float:left,right;margin: left,right</li>\n<li>绝对定位</li>\n<li>float+-margin</li>\n<li>dislplay: table</li>\n<li>flex</li>\n<li>grid</li>\n</ul>\n</li>\n<li>➕flex</li>\n</ul>\n<h2>叁、JavaScript 相关</h2>\n<ul>\n<li>\n<p>➕➕➕<a href=\"https://interview.shanejix.com/#/?id=es6%e6%96%b0%e7%89%b9%e6%80%a7-%f0%9f%94%a5%f0%9f%94%a5\">ES6+新特性 🔥🔥</a></p>\n<ul>\n<li>let，const</li>\n<li>\n<p>和 var 区别</p>\n<ul>\n<li>变量提升</li>\n<li>暂时性死区</li>\n<li>块级作用域</li>\n<li>重复声明</li>\n<li>修改声明的变量</li>\n</ul>\n</li>\n<li>数组扩展</li>\n<li>…</li>\n<li>slice</li>\n<li>splice</li>\n<li>对象扩展</li>\n<li>…</li>\n<li>函数扩展</li>\n<li>箭头函数</li>\n<li>set，map</li>\n<li>\n<p>WeakSet/WeakMap</p>\n<ul>\n<li>成员只能是引用类型（对象作为键），而不能是其他类型的值</li>\n</ul>\n</li>\n<li>\n<h2>场景</h2>\n</li>\n<li>promise</li>\n<li>all</li>\n<li>allSettled()</li>\n<li>race</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=es6-%e4%b8%ad-promise-%e7%9a%84%e7%90%86%e8%a7%a3%ef%bc%9f\">ES6 中 Promise 的理解？</a></li>\n<li>generator</li>\n<li>\n<p>场景</p>\n<ul>\n<li>原生对象没有遍历接口，通过 Generator 函数为它加上这个接口，就能使用 for…of 进行遍历了</li>\n<li>Generator 是异步解决的一种方案</li>\n</ul>\n</li>\n<li>proxy</li>\n<li>moduler</li>\n<li>\n<p>为什么</p>\n<ul>\n<li>代码抽象</li>\n<li>代码封装</li>\n<li>代码复用</li>\n<li>依赖管理</li>\n</ul>\n</li>\n<li>decorator</li>\n</ul>\n</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=javascript-%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b-%f0%9f%94%a5%f0%9f%94%a5\">JavaScript 中的数据类型 🔥🔥</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=javascript-%e4%b8%ad%e7%9a%84%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e6%9c%ba%e5%88%b6-%f0%9f%94%a5%f0%9f%94%a5\">JavaScript 中的类型转换机制 🔥🔥</a></li>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%b7%b1%e6%8b%b7%e8%b4%9d-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">如何实现深拷贝 🔥🔥🔥</a></p>\n<ul>\n<li>浅拷贝</li>\n<li>Object.asign()</li>\n<li>[…arr]</li>\n<li>arr.slice()</li>\n<li>arr.concat()</li>\n<li>深拷贝</li>\n<li>_.deepclone</li>\n<li>\n<p>JSON.stringify()</p>\n<ul>\n<li>undefined</li>\n<li>Symbol</li>\n<li>函数</li>\n</ul>\n</li>\n<li>手写</li>\n</ul>\n</li>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-javascript-%e4%b8%ad%e7%9a%84-this-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">如何理解 JavaScript 中的 this 🔥🔥🔥</a></p>\n<ul>\n<li>是什么</li>\n<li><code class=\"language-text\">this</code> 的值是在代码运行时计算出来的，它取决于`代码上下文</li>\n<li>判断</li>\n<li>默认绑定</li>\n<li>隐式绑定</li>\n<li>new 绑定</li>\n<li>\n<p>显示修改</p>\n<ul>\n<li>call</li>\n<li>apply</li>\n<li>bind</li>\n</ul>\n</li>\n<li>箭头函数</li>\n<li>addEventListener 中的 this 是啥？</li>\n<li>element</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-javascript-%e4%b8%ad%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">如何理解 JavaScript 中执行上下文 🔥🔥🔥</a></p>\n<ul>\n<li>是什么</li>\n<li>执行上下文是一种对 Javascript 代码执行环境的抽象概念，也就是说只要有 Javascript 代码运行，那么它就一定是运行在执行上下文中</li>\n<li>生命周期</li>\n<li>创建</li>\n<li>执行</li>\n<li>回收</li>\n</ul>\n</li>\n<li>➕<a href=\"https://interview.shanejix.com/#/?id=javascript-%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e6%a8%a1%e5%9e%8b-%f0%9f%94%a5\">JavaScript 中的事件模型 🔥</a></li>\n<li>➕<a href=\"https://interview.shanejix.com/#/?id=ajax-%e5%8e%9f%e7%90%86-%f0%9f%94%a5\">Ajax 原理 🔥</a></li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e9%97%ad%e5%8c%85%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e5%8e%9f%e7%90%86-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">闭包的作用和原理 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>函数+变量的总合</li>\n<li>表现</li>\n<li>能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局</li>\n<li>原理</li>\n<li>基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外被访问到</li>\n<li>应用</li>\n<li>无论何时何地，如果将函数作为返回值，就会看到闭包在这些函数中的应用</li>\n<li>在定时器，事件监听器，ajax 请求，跨窗口通信，web workers 或者任何其他的异步/同步任务中，只要使用了回调函数，实际上就是使用闭包</li>\n</ul>\n</li>\n<li>➕➕<a href=\"https://interview.shanejix.com/#/?id=%e5%ae%9e%e7%8e%b0-promise-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">实现 Promise 🔥🔥🔥</a></li>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=es5%e3%80%81es6-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%bb%a7%e6%89%bf-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">ES5、ES6 如何实现继承 🔥🔥🔥</a></p>\n<ul>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%8e%9f%e5%9e%8b%e9%93%be%e7%bb%a7%e6%89%bf\">原型链继承</a></li>\n<li>一个引用类型继承另一个引用类型的属性和方法</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%80%9f%e7%94%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%bb%a7%e6%89%bf\">借用构造函数继承</a></li>\n<li>子类型构造函数中调用父类的构造函数，使所有需要继承的属性都定义在实例对象上</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e7%bb%84%e5%90%88%e7%bb%a7%e6%89%bf%ef%bc%88%e4%bc%aa%e7%bb%8f%e5%85%b8%e7%bb%a7%e6%89%bf%ef%bc%89\">组合继承（伪经典继承）</a></li>\n<li>使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%af%84%e7%94%9f%e7%bb%84%e5%90%88%e5%bc%8f%e7%bb%a7%e6%89%bf\">寄生组合式继承</a></li>\n<li>借用构造函数来继承属性，使用混合式原型链继承方法</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=es6-%e4%b8%ad-class-%e7%9a%84%e7%bb%a7%e6%89%bf\">ES6 中 class 的继承</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=new-%e6%93%8d%e4%bd%9c%e7%ac%a6%e7%9a%84%e5%8e%9f%e7%90%86-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">New 操作符的原理 🔥🔥🔥</a></p>\n<ul>\n<li>是什么</li>\n<li>通过执行自定义构造函数或内置对象构造函数，生成对应的对象实例</li>\n<li>实现</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e8%8a%82%e6%b5%81%e5%92%8c%e9%98%b2%e6%8a%96-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">节流和防抖 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>优化高频触发代码的一种手段，降低事件的触发频率</li>\n<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>\n<li>防抖: n 秒后只运行一次，若在 n 秒内被重复触发，则重新计时</li>\n<li><img src=\"https://cdn.nlark.com/yuque/0/2022/png/377147/1649744054441-79c38d41-75de-4b68-bb8d-2356524c9859.png#clientId=ubfed43c7-cbb4-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=u244c7e99&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=491&#x26;originWidth=750&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=43551&#x26;status=done&#x26;style=none&#x26;taskId=u5c104eea-505d-476d-a32e-48b2c9941bc&#x26;title=#crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;id=qx4ZU&#x26;originHeight=491&#x26;originWidth=750&#x26;originalType=binary&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;status=done&#x26;style=none&#x26;title=\" alt=\"image.png\"></li>\n<li>实现</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=typescript-%e4%b8%ad%e7%9a%84-interface-%e5%92%8c-type-alias%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">TypeScript 中的 Interface 和 Type Alias🔥🔥🔥</a></p>\n<ul>\n<li>区别</li>\n<li>Type 不可在定义后重新添加内容，而 Interface 则总是可以扩展新内容</li>\n<li>相比 Interface，Type 并没有实际创建一个新的类型，而是创建一个引用某个类型的名字</li>\n<li>Interface 只能操作对象类型，Type 可以操作任意类型</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=javascript-%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">JavaScript 异步编程 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>JavaScript 是一种同步的、阻塞的、单线程的语言，一次只能执行一个任务。</li>\n<li>但浏览器定义了非同步的 Web APIs，将回调函数插入到事件循环，实现异步任务的非阻塞执行</li>\n<li>方案</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%bc%82%e6%ad%a5%e5%9b%9e%e8%b0%83\">异步回调</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%ae%9a%e6%97%b6%e5%99%a8%ef%bc%9asettimeoutsetintervalrequestanimationframe\">定时器：setTimeout/setInterval/requestAnimationFrame</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f%ef%bc%88publish-subscribe-pattern%ef%bc%89\">发布/订阅模式（publish-subscribe pattern）</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=promise\">Promise</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e7%94%9f%e6%88%90%e5%99%a8-generator\">生成器 Generator</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=asyncawait\">async/await</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=web-worker\">Web Worker</a></li>\n</ul>\n</li>\n<li>\n<p>➕slice 和 splice 的区别</p>\n<ul>\n<li>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</li>\n</ul>\n</li>\n<li>\n<p>➕➕for in / for of 区别</p>\n<ul>\n<li>for in</li>\n<li>迭代一个对象的除<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">Symbol</a>以外的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">可枚举</a>属性，包括继承的可枚举属性</li>\n<li>为遍历对象属性而构建的</li>\n<li>for of</li>\n<li>循环可迭代对象（数组，Set，Map）</li>\n<li>常用于数组迭代</li>\n</ul>\n</li>\n<li>➕forEach / map 区别</li>\n</ul>\n<h2>肆、Browser 相关</h2>\n<ul>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e8%b7%a8%e5%9f%9f-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">浏览器跨域 🔥🔥🔥</a></p>\n<ul>\n<li>是什么</li>\n<li>同源策略(same-origin policy)是浏览器的为了请求安全而做的限制,协议(protocol)+主机(host)+端口(port)不一致则为跨域</li>\n<li>后端不受此限制,可以通过 CORS 等方式解决跨域</li>\n<li>方案</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=cors-cross-origin-resource-sharing\">CORS (Cross-Origin Resource Sharing)</a></p>\n<ul>\n<li>只需要后端支持</li>\n<li>在响应头中添加 Access-Control-Allow-*</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86\">反向代理</a></p>\n<ul>\n<li>只需要后端支持</li>\n<li>依赖同源的服务端对请求做一个转发处理，将跨域请求转换成同源请求</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=jsonp\">JSONP</a></p>\n<ul>\n<li>需要服务端和前端配合实现</li>\n<li>利用了浏览器加载 JavaScript 资源文件时不受同源策略的限制而实现跨域获取数据</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e9%9d%9e%e5%b8%b8%e7%94%a8%e6%96%b9%e5%bc%8f\">非常用方式</a></p>\n<ul>\n<li>postMessage</li>\n<li>即在两个 origin 下分别部署一套页面 A 与 B，</li>\n<li>A 页面通过 iframe 加载 B 页面并监听消息，B 页面发送消息</li>\n<li>window.name</li>\n<li>主要是利用 <a href=\"http://window.name/\">window.name</a> 页面跳转不改变的特性实现跨域，</li>\n<li>即 iframe 加载一个跨域页面，设置 <a href=\"http://window.name/\">window.name</a>，跳转到同域页面，可以通过 $(‘iframe’).<a href=\"http://contentwindow.name/\">contentWindow.name</a> 拿到跨域页面的数据</li>\n<li>document.domain</li>\n<li>可将相同一级域名下的子域名页面的 document.domain 设置为一级域名实现跨域</li>\n<li>可将同域不同端口的 document.domain 设置为同域名实现跨域（端口被置为 null）</li>\n</ul>\n</li>\n<li>\n<p>扩展</p>\n<ul>\n<li>LocalStorage / SessionStorage 跨域</li>\n<li>跨域与监控</li>\n<li>跨域与图片</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e9%87%8d%e6%8e%92%e9%87%8d%e7%bb%98-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">浏览器的重排重绘 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>浏览器渲染大致分为四个阶段，在解析完 HTML 依次进入 layout （重排）和 paint （重绘）。</li>\n<li>节点或者样式的变更以及对布局信息的访问等，都可能导致重排或者重绘；</li>\n<li>重排和重绘在主线程中进行，者意味着不合理的重排和重绘会导致页面卡顿等性能问题</li>\n<li>为什么？</li>\n<li>不合理的重排和重绘会导致占用浏览器主线程，导致卡顿等性能问题</li>\n<li>浏览器渲染关键路径</li>\n<li>\n<p>parse HTML</p>\n<ul>\n<li>dom tree</li>\n<li>cssom tree</li>\n<li>render tree</li>\n</ul>\n</li>\n<li>\n<p>lauyout</p>\n<ul>\n<li>尺寸</li>\n<li>位置</li>\n</ul>\n</li>\n<li>\n<p>paint</p>\n<ul>\n<li>节点到像素</li>\n<li>发生在多个图层</li>\n</ul>\n</li>\n<li>\n<p>composition</p>\n<ul>\n<li>合并图层</li>\n<li>渲染到屏幕</li>\n</ul>\n</li>\n<li>触发</li>\n<li>\n<p>节点变更-导致重排</p>\n<ul>\n<li>盒子尺寸、类型</li>\n<li>定位方案</li>\n<li>文档中节点关系</li>\n<li>外部信息（视口）</li>\n<li>第一次渲染</li>\n</ul>\n</li>\n<li>\n<p>外观变化-导致重绘</p>\n<ul>\n<li>样式改变</li>\n</ul>\n</li>\n<li>\n<p>获取布局信息（会及时计算所以会重排）</p>\n<ul>\n<li>属性</li>\n<li>offset 系列</li>\n<li>client 系列</li>\n<li>scroll 系列</li>\n<li>方法</li>\n<li>getComputeStyle</li>\n</ul>\n</li>\n<li>减少（方案）</li>\n<li>对 DOM 进行批量写入和读取（通过虚拟 DOM 或者 DocumentFragment 实现）</li>\n<li>避免对样式频繁操作</li>\n<li>避免频繁读取样式信息，使用变量缓存</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e4%bb%8e%e8%be%93%e5%85%a5%e7%bd%91%e5%9d%80%e5%88%b0%e9%a1%b5%e9%9d%a2%e5%b1%95%e7%a4%ba%e7%9a%84%e8%bf%87%e7%a8%8b-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">浏览器从输入网址到页面展示的过程 🔥🔥🔥</a></p>\n<ul>\n<li>url 输入</li>\n<li>合法性校验</li>\n<li>dns 解析</li>\n<li>浏览器 DNS 缓存</li>\n<li>操作系统的 DNS 缓存（hosts）</li>\n<li>本地域名服务器（递归查询）</li>\n<li>上级域名服务器（迭代查询）</li>\n<li>建立 tcp 连接（三次握手）</li>\n<li>-</li>\n<li>发送 http 请求</li>\n<li>请求行</li>\n<li>请求头</li>\n<li>请求体</li>\n<li>服务器响应请求</li>\n<li>响应行</li>\n<li>响应头</li>\n<li>响应体</li>\n<li>浏览器解析页面</li>\n<li>\n<p>查看响应头的信息，根据不同的指示做对应处理</p>\n<ul>\n<li>重定向</li>\n<li>存储 cookie</li>\n<li>解压 gzip</li>\n<li>缓存资源</li>\n<li>根据不同的资源类型（Content-Type）采用不同的解析方式</li>\n</ul>\n</li>\n<li>\n<p>浏览器渲染关键路径</p>\n<ul>\n<li>parse HTML</li>\n<li>dom tree</li>\n<li>cssom tree</li>\n<li>render tree</li>\n<li>lauyout</li>\n<li>尺寸</li>\n<li>位置</li>\n<li>paint</li>\n<li>节点到像素</li>\n<li>发生在多个图层</li>\n<li>composition</li>\n<li>合并图层</li>\n<li>渲染到屏幕</li>\n</ul>\n</li>\n<li>断开 tcp 连接（四次挥手）</li>\n<li>tab 标签页关闭时</li>\n</ul>\n</li>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">浏览器渲染机制 🔥🔥🔥</a></p>\n<ul>\n<li>关键路径</li>\n<li>\n<p>parse HTML</p>\n<ul>\n<li>构建 dom tree</li>\n<li>Conversion（转换）：字节 =》字符</li>\n<li>Tokenizing（分词）：, 等标记</li>\n<li>Lexing（语法分析）：标记将被转换为对象（包含属性，属性值，文本等）</li>\n<li>DOM construction（DOM 构造）：连接对象生成树结构</li>\n<li>预加载次级资源</li>\n<li>预加载扫描器（preload scanner）线程并发加载图片、JavaScript、CSS、字体等资源</li>\n<li>遇到 script 标签时，会暂停 HTML 的解析</li>\n</ul>\n</li>\n<li>\n<p>style 样式计算</p>\n<ul>\n<li>构建 cssom tree</li>\n<li>搜集样式，建立索引</li>\n<li>遍历 DOM 树，通过选择器匹配样式，并设置样式</li>\n<li>层叠样式，生成最终样式</li>\n<li>CSSOM 和 DOM 是并行构建</li>\n<li>CSSOM 会阻塞 JS 的执行（因为 JS 可能会操作样式信息）</li>\n<li>但在进入下一阶段之前，必须等待 CSSOM 构建完成（这也是通常所说的 CSSOM 会阻塞渲染）</li>\n</ul>\n</li>\n<li>\n<p>lauyout</p>\n<ul>\n<li>合并 layout tree</li>\n<li>\n<p>计算可见的节点及其样式</p>\n<ul>\n<li>从 dom 树 遍历每个可见节点</li>\n<li>为其找到适配的 CSSOM 规则并应用（包含内容和样式）</li>\n</ul>\n</li>\n<li>\n<p>确切位置和大小</p>\n<ul>\n<li>根据 CSS 盒模型及视觉格式化模型，计算每个元素的各种生成盒的大小和位置</li>\n<li>计算块级元素、行内元素、浮动元素、各种定位元素的大小和位置</li>\n<li>计算文字，滚动区域的大小和位置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>paint</p>\n<ul>\n<li>将 LayoutObject 树转换成供合成器使用的高效渲染格式</li>\n<li>节点到像素</li>\n<li>发生在多个图层</li>\n</ul>\n</li>\n<li>\n<p>composition</p>\n<ul>\n<li>合并图层</li>\n<li>渲染到屏幕</li>\n</ul>\n</li>\n<li>优化性能</li>\n<li>\n<p>保证渲染流程不被阻塞，避免不必要的绘制计算和重排重绘</p>\n<ul>\n<li>（以动画为例）</li>\n<li>使用合适的网页分层技术：如使用多层 canvas，将动画背景，运动主体，次要物体分层，这样每一帧需要变化的就只是一个或部分合成层，而不是整个页面</li>\n<li>使用 CSS Transforms 和 Animations：它可以让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果，而不需要重新计算布局，重新绘制图形</li>\n</ul>\n</li>\n<li>\n<p>优化影响渲染的资源</p>\n<ul>\n<li>关键 CSS 资源放在头部加载。</li>\n<li>JS 通常放在页面底部。</li>\n<li>为 JS 添加 async 和 defer 属性。</li>\n<li>body 中尽量不要出现 CSS 和 JS。</li>\n<li>为 img 指定宽高，避免图像加载完成后触发重排。</li>\n<li>避免使用 table, iframe 等慢元素。原因是 table 会等到它的 dom 树全部生成后再一次性插入页面中；iframe 内资源的下载过程会阻塞父页面静态资源的下载及 css, dom 树的解析</li>\n</ul>\n</li>\n<li>用 GPU 硬件加速</li>\n</ul>\n</li>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6-%f0%9f%94%a5%f0%9f%94%a5\">垃圾回收机制 🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>一种内存自动管理机制， 垃圾回收器（Garbage Collector）可以自动回收分配给程序的已经不再使用的内存</li>\n<li>常见的 GC 算法有引用计数法和标记清除法等</li>\n<li>内存泄漏</li>\n<li>应当被回收的对象没有被正常回收</li>\n<li>方案</li>\n<li>标记清除</li>\n<li>引用计数</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">浏览器事件循环 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>一种程序结构，消息分发器</li>\n<li>浏览器主线程是单线程的，为了使定时器，用户脚本等异步操作非阻塞的运行，浏览器通过任务队列来管理异步任务</li>\n<li>事件调度</li>\n<li>执行同步代码。</li>\n<li>执行一个宏任务（执行栈中没有就从任务队列中获取）</li>\n<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>\n<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后渲染线程接管进行渲染</li>\n<li>渲染完毕后，JavaScript 线程继续接管，开始下一个循环</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%ae%8f%e4%bb%bb%e5%8a%a1%e4%b8%8e%e5%be%ae%e4%bb%bb%e5%8a%a1\">宏任务与微任务</a></li>\n<li>宏任务主要包含：</li>\n<li>\n<p>script（整体代码）、</p>\n<ul>\n<li>setTimeout、</li>\n<li>setInterval、</li>\n<li>setImmediate、</li>\n<li>I/O、</li>\n<li>UI 交互事件</li>\n</ul>\n</li>\n<li>\n<p>微任务主要包含：</p>\n<ul>\n<li>Promise、</li>\n<li>MutationObserver</li>\n</ul>\n</li>\n<li>常考例题</li>\n<li><a href=\"https://juejin.cn/post/6844903762478235656\">令人费解的 async/await 执行顺序 - 掘金 (juejin.cn)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e5%a6%82%e4%bd%95%e5%ae%9a%e4%bd%8d%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2-%f0%9f%94%a5\">如何定位内存泄露 🔥</a></p>\n<ul>\n<li>devtools</li>\n<li>Performance</li>\n<li>Memory</li>\n<li>—inspect</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=%e5%89%8d%e7%ab%af%e8%b7%af%e7%94%b1%e5%ae%9e%e7%8e%b0-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">前端路由实现 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>源地址到目标地址的活动</li>\n<li>Web：url 到对应程序的映射</li>\n<li>实现</li>\n<li>前后端均可实现</li>\n<li>\n<p>前端路由</p>\n<ul>\n<li>hash 路由</li>\n<li>触发 onhaschange 监听 hash 的变化</li>\n<li>不会重新刷新页面</li>\n<li>改变浏览器历史记录</li>\n<li>history 路由(依赖 History API 里的两个方法和一个事件)</li>\n<li>history.pushState</li>\n<li>hisstory.replaceState</li>\n<li>popstate</li>\n</ul>\n</li>\n<li>应用</li>\n<li>无刷新的单页应用开发模式 SPA</li>\n<li>优缺点</li>\n<li>\n<p>hash</p>\n<ul>\n<li>兼容性最佳</li>\n<li>无需服务端配置</li>\n<li>服务端无法获取 hash 部分内容</li>\n<li>可能和锚点功能冲突</li>\n<li>SEO 不友好</li>\n</ul>\n</li>\n<li>\n<p>histroy</p>\n<ul>\n<li>服务端可获取完整的链接和参数。</li>\n<li>前端监控友好。</li>\n<li>SEO 相对 Hash 路由友好。</li>\n<li>兼容性稍弱。</li>\n<li>需要服务端额外配置（各 path 均指向同一个 HTML）。</li>\n</ul>\n</li>\n<li>-</li>\n</ul>\n</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=dom-ampamp-bom%f0%9f%94%a5\">DOM &#x26;&#x26; BOM🔥</a></li>\n<li>\n<p>➕ 正则表达式</p>\n<ul>\n<li>创建</li>\n<li>字面量</li>\n<li>RegExp 构造函数</li>\n<li>匹配规则</li>\n<li>贪婪模式</li>\n<li>懒惰模式</li>\n<li>分组</li>\n<li>匹配方法</li>\n<li>match、matchAll、search、replace、split</li>\n<li>test、exec</li>\n</ul>\n</li>\n</ul>\n<h2>伍、网络协议</h2>\n<ul>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=%e5%89%8d%e7%ab%af%e5%ae%89%e5%85%a8-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">前端安全 🔥🔥🔥</a></p>\n<ul>\n<li>XSS（跨站脚本攻击）</li>\n<li>\n<p>是什么</p>\n<ul>\n<li>将代码注入到其他用户浏览器的攻击方式</li>\n</ul>\n</li>\n<li>\n<p>类型</p>\n<ul>\n<li>反射型（非持久性）</li>\n<li>\n<p>原理：</p>\n<ul>\n<li>攻击者通过在 URL 插入恶意代码，其他用户访问该恶意链接时，服务端在 URL 取出恶意代码后拼接至 HTML 中返回给用户浏览器</li>\n</ul>\n</li>\n<li>\n<p>要点：</p>\n<ul>\n<li>通过 URL 插入恶意代码</li>\n<li>有服务端参与</li>\n<li>需要用户访问特定链接</li>\n</ul>\n</li>\n<li>存储型（持久性）</li>\n<li>\n<p>原理：</p>\n<ul>\n<li>攻击者将注入型脚本提交至被攻击网站数据库中，当其他用户浏览器请求数据时，注入脚本从服务器返回并执行</li>\n</ul>\n</li>\n<li>\n<p>要点：</p>\n<ul>\n<li>恶意代码存储在目标网站服务器上</li>\n<li>有服务端参与</li>\n<li>只要用户访问被注入恶意脚本的页面时，就会被攻击</li>\n</ul>\n</li>\n<li>DOM 型</li>\n<li>\n<p>原理：</p>\n<ul>\n<li>攻击者通过在 URL 插入恶意代码，客户端脚本取出 URL 中的恶意代码并执行。</li>\n</ul>\n</li>\n<li>\n<p>要点：</p>\n<ul>\n<li>在客户端发生</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e9%98%b2%e8%8c%83-xss\">防范 XSS</a></p>\n<ul>\n<li>对于外部传入的内容进行充分转义</li>\n<li>开启 CSP（Content Security Policy，内容安全策略），规定客户端哪些外部资源可以加载和执行，降低 XSS 风险</li>\n<li>设置 Cookie httpOnly 属性，禁止 JavaScript 读取 Cookie 防止被窃取</li>\n</ul>\n</li>\n<li>CSRF（跨站请求伪造）</li>\n<li>\n<p>是什么</p>\n<ul>\n<li>窃用其身份在对应的网站进行操作</li>\n</ul>\n</li>\n<li>\n<p>要点：</p>\n<ul>\n<li>利用浏览器在发送 HTTP 请求时会自动带上 Cookie 的原理，冒用受害者身份请求</li>\n<li>攻击一般发生在第三方网站上</li>\n<li>攻击者只能“冒用”受害者的身份凭证，并不能获取</li>\n<li>跨站请求有多种方式，常见的有图片 URL、超链接、Form 提交等</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e9%98%b2%e8%8c%83-csrf\">防范 CSRF</a></p>\n<ul>\n<li>使用 CSRF Token 验证用户身份</li>\n<li>双重 Cookie 验证</li>\n<li>设置 Cookie 的 SameSite 属性可以用来限制第三方 Cookie 的使用</li>\n</ul>\n</li>\n<li>中间人攻击（MITM）</li>\n<li>\n<p>是什么</p>\n<ul>\n<li>攻击者与通讯的两端分别创建独立的联系，在通讯中充当一个中间人角色对数据进行监听、拦截甚至篡改</li>\n</ul>\n</li>\n<li>\n<p>原理</p>\n<ul>\n<li>拦截</li>\n<li>解密</li>\n<li>SSL 劫持（伪造证书）</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb%e9%98%b2%e8%8c%83\">中间人攻击防范</a></p>\n<ul>\n<li>对于开发者来说：</li>\n<li>支持 HTTPS</li>\n<li>对于用户来说：</li>\n<li>尽可能使用 HTTPS 链接</li>\n<li>避免连接不知名的 WiFi 热点</li>\n<li>不忽略不安全的浏览器通知</li>\n<li>公共网络不进行涉及敏感信息的交互</li>\n<li>用可信的第三方 CA 厂商，不下载来源不明的证书</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=http-%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">HTTP 缓存机制 🔥🔥🔥</a></p>\n<ul>\n<li>强缓存</li>\n<li>\n<p>是什么</p>\n<ul>\n<li>可以通过 Expires / Cache-Control 控制</li>\n<li>命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 200 from cache</li>\n</ul>\n</li>\n<li>\n<p>expires</p>\n<ul>\n<li>HTTP/1.0 产物。</li>\n<li>优先级低于 Cache-control: max-age。</li>\n<li>缺点：使用本地时间判断是否过期，而本地时间是可修改的且并非一定准确的</li>\n</ul>\n</li>\n<li>\n<p>cache-control</p>\n<ul>\n<li>HTTP/1.1 产物</li>\n<li>优先级高于 Expires</li>\n<li>正确区分 no-cache / no-store 的作用</li>\n<li>no-cache 强制客户端向服务器发起请求（禁用强缓存，可用协商缓存）。</li>\n<li>no-store 禁止一切缓存，包含协商缓存也不可用。</li>\n</ul>\n</li>\n<li>协商缓存</li>\n<li>\n<p>是什么</p>\n<ul>\n<li>可以通过 Last-Modified / If-Modified-Since 和 Etag / If-None-Match 控制，</li>\n<li>开启协商缓存时向服务器发送的请求会带上缓存标识，若命中协商缓存，服务器返回 304 Not Modified 表示浏览器可以使用本地缓存文件，否则返回 200 OK 正常返回数据</li>\n</ul>\n</li>\n<li>\n<p>Last-Modified / If-Modified-Since</p>\n<ul>\n<li>通过资源的最后修改时间来验证缓存。</li>\n<li>优先级低于 ETag / If-None-Match。</li>\n<li>缺点：只能精确到秒，若 1s 内多次修改资源 Last-Modified 不会变化</li>\n</ul>\n</li>\n<li>\n<p>ETag / If-None-Match</p>\n<ul>\n<li>通过唯一标识来验证缓存。</li>\n<li>优先级高于 Last-Modified / If-Modified-Since。</li>\n</ul>\n</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e7%bc%93%e5%ad%98%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9\">优缺点</a></li>\n<li>\n<p>优点</p>\n<ul>\n<li>节省了不必要的数据传输，节省带宽。</li>\n<li>减少服务端的负担，提高网站性能。</li>\n<li>降低网络延迟，加快页面响应速度，增强用户体验。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>不恰当的缓存设置可能会导致资源更新不及时，导致用户获取信息滞后。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=http2-%e5%92%8c-http11-%e7%9a%84%e5%af%b9%e6%af%94-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">HTTP/2 和 HTTP/1.1 的对比 🔥🔥🔥</a></p>\n<ul>\n<li>HTTP/1.1 相较 HTTP/1.0 的改进和优化：</li>\n<li>\n<p>持久连接</p>\n<ul>\n<li>Connection: keep-alive</li>\n</ul>\n</li>\n<li>\n<p>HTTP 管道化</p>\n<ul>\n<li>多个 HTTP 同时请求，响应必须按照请求发出的顺序依次返回</li>\n<li>问题</li>\n<li>对头阻塞</li>\n<li>服务端缓存前序请求</li>\n</ul>\n</li>\n<li>\n<p>分块编码传输</p>\n<ul>\n<li>Transfer-Encoding: chunked</li>\n</ul>\n</li>\n<li>\n<p>新增 Host 头处理</p>\n<ul>\n<li>http/1.0 每台服务器都绑定一个唯一的 IP 地址(因此一台服务器也无法搭建多个 Web 站点)</li>\n</ul>\n</li>\n<li>\n<p>断点续传、并行下载</p>\n<ul>\n<li>请求头字段 Range</li>\n<li>响应头字段 Content-Range</li>\n</ul>\n</li>\n<li>HTTP/1.1 的缺点：</li>\n<li>队头阻塞（Head-of-line blocking）</li>\n<li>\n<p>头部冗余</p>\n<ul>\n<li>HTTP 请求每次都会带上请求头,若此时 cookie 也携带大量数据</li>\n</ul>\n</li>\n<li>TCP 连接数限制</li>\n<li>HTTP/2 的优点：</li>\n<li>\n<p>二进制分帧层</p>\n<ul>\n<li>在 HTTP/1.x 中传输数据使用的是纯文本形式的报文,需要不断地读入字节直到遇到分隔符为</li>\n<li>HTTP/2 则是采用二进制编码，将请求和响应数据分割为一个或多个的体积小的帧</li>\n</ul>\n</li>\n<li>\n<p>多路复用</p>\n<ul>\n<li>并行地处理多个请求和响应</li>\n</ul>\n</li>\n<li>Header 压缩</li>\n<li>服务端推送</li>\n</ul>\n</li>\n<li>\n<p>get 和 post 的区别</p>\n<ul>\n<li>从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>\n<li>从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li>\n<li>从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>\n<li>从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li>\n<li>从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li>\n</ul>\n</li>\n<li>\n<p>➕https</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\">图解 SSL/TLS 协议 - 阮一峰的网络日志 (ruanyifeng.com)</a></li>\n</ul>\n</li>\n</ul>\n<h2>陆、前端工程化</h2>\n<ul>\n<li>\n<p>➕<a href=\"https://interview.shanejix.com/#/?id=webpack-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">Webpack 工作原理 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>webpack 是一种模块打包工具,可以将各类资源(js,css,图片,字体等-一切皆可打包)转译组合为 JS 格式 的 bundle 文件</li>\n<li>为什么？</li>\n<li>提高效率</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5\">基本概念</a></li>\n<li>Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入</li>\n<li>Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块</li>\n<li>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割</li>\n<li>Loader：模块转换器，用于把模块原内容按照需求转换成新内容</li>\n<li>Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e6%a0%b8%e5%bf%83%e4%bb%bb%e5%8a%a1\">核心任务</a></li>\n<li>完成内容转化和资源合并,可以分为以下三大阶段</li>\n<li>\n<p>初始化阶段</p>\n<ul>\n<li>读取与合并配置参数</li>\n<li>实例化 Compiler</li>\n<li>加载 Plugin</li>\n</ul>\n</li>\n<li>\n<p>编译阶段</p>\n<ul>\n<li>从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容</li>\n<li>再找到该 Module 依赖的 Module，递归地进行编译处理</li>\n</ul>\n</li>\n<li>\n<p>输出阶段</p>\n<ul>\n<li>对编译后的 Module 组合成 Chunk</li>\n<li>把 Chunk 转换成文件，输出到文件系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=%e5%89%8d%e7%ab%af%e6%a8%a1%e5%9d%97%e5%8c%96%e8%a7%84%e8%8c%83-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">前端模块化规范 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li><a href=\"https://nodejs.org/api/modules.html#modules_modules_commonjs_modules\">CommonJS</a>: 主要是 Node.js 使用，通过 require 同步加载模块，exports 导出内容</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Asynchronous_module_definition\">AMD</a>: 主要是浏览器端使用，通过 require 异步加载模块，通过 define 定义模块和依赖，推崇依赖前置</li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\">CMD</a>: 和 AMD 比较类似，主要是浏览器端使用，通过 require 异步加载模块，exports 导出内容，推崇依赖就近</li>\n<li><a href=\"https://github.com/umdjs/umd/\">UMD</a>: 通用模块规范，是 CommonJS、AMD 两个规范的大融合，是跨平台的解决方案</li>\n<li>ESM: 官方模块化规范，现代浏览器原生支持，通过 import 异步加载模块，export 导出内容</li>\n<li>为什么？</li>\n<li>模块化可以解决代码之间的变量、函数、对象等命名的冲突/污染问题，良好的模块化设计可以降低代码之间的耦合关系，提高代码的可维护性、可扩展性以及复用性</li>\n<li>模块化规范的作用是为了规范 JavaScript 模块的定义和加载机制，以统一的方式导出和加载模块，降低学习使用成本，提高开发效率</li>\n<li>优缺点</li>\n<li>-</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=babel-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e5%8e%9f%e7%90%86-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">Babel 的作用和原理 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>Babel 是 JavaScript 编译器</li>\n<li>Babel 内部原理是将 JS 代码转换为 AST，对 AST 应用各种插件进行处理，最终输出编译后的 JS 代码</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=babel-%e7%bc%96%e8%af%91%e6%b5%81%e7%a8%8b\">Babel 编译流程</a></li>\n<li>\n<p>解析阶段：Babel 默认使用 @babel/parser 将代码转换为 AST。解析一般分为两个阶段：词法分析和语法分析</p>\n<ul>\n<li>词法分析：对输入的字符序列做标记化(tokenization)操作。</li>\n<li>语法分析：处理标记与标记之间的关系，最终形成一颗完整的 AST 结构。</li>\n</ul>\n</li>\n<li>\n<p>转换阶段：</p>\n<ul>\n<li>Babel 使用 @babel/traverse 提供的方法对 AST 进行深度优先遍历，调用插件对关注节点的处理函数，按需对 AST 节点进行增删改操作</li>\n</ul>\n</li>\n<li>\n<p>生成阶段：</p>\n<ul>\n<li>Babel 默认使用 @babel/generator 将上一阶段处理后的 AST 转换为代码字符串</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e8%b0%88%e4%b8%8b-webpack-loader-%e7%9a%84%e6%9c%ba%e5%88%b6-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">谈下 webpack loader 的机制 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>loader 本质上是一个函数，该函数对接收到的内容进行转换，返回转换后的结果</li>\n<li>webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。loader 将其他类型的文件转换成有效的 webpack modules（如 ESmodule、CommonJS、AMD），webpack 能消费这些模块，并将其添加到依赖关系图中</li>\n<li>常见的 loader 有：</li>\n<li>raw-loader：加载文件原始内容。</li>\n<li>file-loader：将引用文件输出到目标文件夹中，在代码中通过相对路径引用输出的文件。</li>\n<li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式将文件内容注入到代码中。</li>\n<li>babel-loader：将 ES 较新的语法转换为浏览器可以兼容的语法。</li>\n<li>style-loader：将 CSS 代码注入到 JavaScript 中，通过 DOM 操作加载 CSS。</li>\n<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性。</li>\n</ul>\n</li>\n<li>\n<p>➕➕➕ 提高 webpack 的构建速度</p>\n<ul>\n<li>缩小查找范围</li>\n<li>指定 loader 的 include，exlude，正则</li>\n<li>指定 node_modules 为决定路径，优化 resolve.modules</li>\n<li>指定文件后缀，合理使用 resolve.extensions</li>\n<li>优化 resolve.alias</li>\n<li>使用缓存，cache-loader</li>\n<li>启用多线程</li>\n<li>合理使用 soucemap</li>\n<li>开发模式上 vite</li>\n</ul>\n</li>\n<li>\n<p>➕ 为什么用 webpack 用 gulp 不行么</p>\n<ul>\n<li>gulp 强调的是一个前端构建工作流（配置一系列的 task（压缩，编译，复制，启动）并发或者按照一定顺序执行）</li>\n<li>webpack 侧重打包（模块化）可以把开发中所有的资源（js，css，图片，字体）都看作模块，通过 loader 和 plugin 进行处理，最终生成 bundle</li>\n<li><a href=\"https://www.cnblogs.com/lovesong/p/6413546.html\">gulp 与 webpack 的区别 - 海角在眼前 - 博客园 (cnblogs.com)</a></li>\n</ul>\n</li>\n<li>\n<p>➕ 为什么使用 monorepo？</p>\n<ul>\n<li>mutirepo 的痛点</li>\n<li>代码难以复用</li>\n<li>优点</li>\n<li>统一的工作流</li>\n<li>代码复用</li>\n<li>工程管理</li>\n</ul>\n</li>\n</ul>\n<h2>柒、框架和类库</h2>\n<ul>\n<li>\n<p>➕➕➕<a href=\"https://interview.shanejix.com/#/?id=react-fiber-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e5%8e%9f%e7%90%86-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">React Fiber 的作用和原理 🔥🔥🔥</a></p>\n<ul>\n<li>是什么？</li>\n<li>是 React 16 中采用的新协调（reconciliation）引擎，主要目标是支持虚拟 DOM 的渐进式渲染</li>\n<li>对比</li>\n<li>\n<p>Stack Reconciler 替换为 Fiber Reconciler</p>\n<ul>\n<li>任务的分片</li>\n<li>任务划分优先级</li>\n<li>任务可挂起、恢复、终止等操作</li>\n</ul>\n</li>\n<li>Fiber 的主要工作流程：</li>\n<li>ReactDOM.render() 引导 React 启动或调用 setState() 的时候开始创建或更新 Fiber 树。</li>\n<li>\n<p>从根节点开始遍历 Fiber Node Tree， 并且构建 workInProgress Tree（reconciliation 阶段）。</p>\n<ul>\n<li>本阶段可以暂停、终止、和重启，会导致 react 相关生命周期重复执行。</li>\n<li>React 会生成两棵树，一棵是代表当前状态的 current tree，一棵是待更新的 workInProgress tree。</li>\n<li>遍历 current tree，重用或更新 Fiber Node 到 workInProgress tree，workInProgress tree 完成后会替换 current tree。</li>\n<li>每更新一个节点，同时生成该节点对应的 Effect List。</li>\n<li>为每个节点创建更新任务。</li>\n</ul>\n</li>\n<li>\n<p>将创建的更新任务加入任务队列，等待调度。</p>\n<ul>\n<li>调度由 scheduler 模块完成，其核心职责是执行回调。</li>\n<li>scheduler 模块实现了跨平台兼容的 requestIdleCallback。</li>\n<li>每处理完一个 Fiber Node 的更新，可以中断、挂起，或恢复。</li>\n</ul>\n</li>\n<li>\n<p>根据 Effect List 更新 DOM （commit 阶段）。(<a href=\"https://github.com/facebook/react/pull/19673\">已经弃用 effectList</a>）</p>\n<ul>\n<li>React 会遍历 Effect List 将所有变更一次性更新到 DOM 上。</li>\n<li>这一阶段的工作会导致用户可见的变化。因此该过程不可中断，必须一直执行直到更新完成</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=hoc-vs-render-props-vs-hooks%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">HOC vs Render Props vs Hooks🔥🔥🔥</a></li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=react-hooks-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">React Hooks 实现原理 🔥🔥🔥</a></p>\n<ul>\n<li>原理？</li>\n<li>Hooks 主要是利用闭包来保存状态，使用链表保存一系列 Hooks，将链表中的第一个 Hook 与 Fiber 关联。</li>\n<li>在 Fiber 树更新时，就能从 Hooks 中计算出最终输出的状态和执行相关的副作用。</li>\n<li>实现</li>\n</ul>\n</li>\n<li>\n<p>➕➕➕<a href=\"https://interview.shanejix.com/#/?id=react-%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6%e5%8e%9f%e7%90%86-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">React 事件机制原理 🔥🔥🔥</a></p>\n<ul>\n<li>原理</li>\n<li>\n<p>两个阶段：</p>\n<ul>\n<li>初始化渲染时在 root 节点上注册原生事件的回调；</li>\n<li>原生事件触发时模拟捕获目标和冒泡阶段派发合成事件</li>\n</ul>\n</li>\n<li>优点</li>\n<li>通过这种机制，冒泡的原生事件类型最多在 root 节点上注册一次，节省内存开销。</li>\n<li>且 React 为不同类型的事件定义了不同的处理优先级，从而让用户代码及时响应高优先级的用户交互，提升用户体验。</li>\n<li>处理</li>\n<li>React 的事件机制中依赖合成事件这个核心概念。</li>\n<li>合成事件在符合 W3C 规范定义的前提下，抹平浏览器之间的差异化表现。</li>\n<li>\n<p>并且简化事件逻辑，对关联事件进行合成。</p>\n<ul>\n<li>如每当表单类型组件的值发生改变时，都会触发 onChange 事件，而 onChange 事件由 change、click、input、keydown、keyup 等原生事件组成。</li>\n</ul>\n</li>\n<li>流程</li>\n<li>原生事件触发后，进入 dispatchEvent 回调方法；</li>\n<li>attemptToDispatchEvent 方法根据该原生事件查找到当前原生 Dom 节点和映射的 Fiber 节点；</li>\n<li>事件和 Fiber 等信息被派发给插件系统进行处理，插件系统调用各插件暴露的 extractEvents 方法；</li>\n<li>accumulateSinglePhaseListeners 方法向上收集 Fiber 树上监听相关事件的其他回调函数，构造合成事件并加入到派发队列 dispatchQueue 中；</li>\n<li>调用 processDispatchQueue 方法，基于捕获或冒泡阶段的标识，按倒序或顺序执行 dispatchQueue 中的方法；</li>\n</ul>\n</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%b8%b8%e8%a7%81%e6%a1%86%e6%9e%b6%e7%9a%84-diff-%e7%ae%97%e6%b3%95-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">常见框架的 Diff 算法 🔥🔥🔥</a></li>\n<li>\n<p>mvc 和 mvvm 的区别</p>\n<ul>\n<li><a href=\"https://www.nowcoder.com/tutorial/96/fe3aa17fdbfe4c919975a03f3082bd5d\">【前端工程师面试宝典】学习说明<em>互联网校招面试真题面经汇总</em>牛客网 (nowcoder.com)</a></li>\n</ul>\n</li>\n<li>\n<p>单页应用如何在浏览器中实现的？单页应用的优缺点</p>\n<ul>\n<li><a href=\"https://www.nowcoder.com/tutorial/96/fe3aa17fdbfe4c919975a03f3082bd5d\">【前端工程师面试宝典】学习说明<em>互联网校招面试真题面经汇总</em>牛客网 (nowcoder.com)</a></li>\n</ul>\n</li>\n<li>➕➕ 高阶组件</li>\n</ul>\n<h2>捌、React 相关</h2>\n<ul>\n<li>\n<p>➕➕➕01 你真的了解 React 么？</p>\n<ul>\n<li>是什么？（一句话概括）（干嘛的，用途）</li>\n<li>（渐进式）UI 框架</li>\n<li>通过组件化的方式解决 UI 复用的问题</li>\n<li>本质是一个组件化的 UI 框架</li>\n<li>设计思路（特点）</li>\n<li>\n<p>声明式</p>\n<ul>\n<li>声明式的有点在于直观和组合</li>\n</ul>\n</li>\n<li>\n<p>组件化</p>\n<ul>\n<li>组件化的优点在于便于组件的拆分和组合，更容易做到低耦合和高内聚</li>\n</ul>\n</li>\n<li>\n<p>通用性</p>\n<ul>\n<li>通用性的优点在于一次学习，多处使用</li>\n</ul>\n</li>\n<li>优缺点</li>\n<li>\n<p>优点</p>\n<ul>\n<li>适用范围广，web，native 等</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>不是大而全的框架，生态需要社区维护</li>\n</ul>\n</li>\n<li>和 vue 的对比！！</li>\n<li>注意引导</li>\n<li>优化</li>\n<li>虚拟 dom</li>\n<li>自己的项目</li>\n<li>工程架构和设计模式等</li>\n</ul>\n</li>\n<li>\n<p>02 为什么要用 jsx？</p>\n<ul>\n<li>（潜台词：为什么不用 a，b，b）</li>\n<li>一句话解释</li>\n<li>JavaScript 的语法扩展，类似于 xml 语法</li>\n<li>核心概念</li>\n<li>不强制使用，React.createElement()的语法糖</li>\n<li>方案对比</li>\n<li>\n<p>模板</p>\n<ul>\n<li>弱关注点分离</li>\n<li>引入了概念多</li>\n</ul>\n</li>\n<li>\n<p>模板字符串</p>\n<ul>\n<li>结构描述复杂</li>\n<li>语法提示差</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕➕03 声明周期中的坑？</p>\n<ul>\n<li>(潜台词：为什么会有坑）</li>\n<li>恰当的时机做恰当的事情</li>\n<li>周期梳理（类组件）</li>\n<li>\n<p>挂在阶段</p>\n<ul>\n<li>constructor</li>\n<li>类构造函数初始化 state 和绑定函数</li>\n<li>\n<p>类属性流行后去除了 constructor</p>\n<ul>\n<li>不推荐做初始化以外的逻辑</li>\n<li>不属于 react 的生命周期，只是类构造函数的初始化函数</li>\n<li>更简洁</li>\n</ul>\n</li>\n<li>getDerivedStateFromProps</li>\n<li>在 props 变化时，更新 state</li>\n<li>\n<p>触发时机（并非 props 变化时执行）</p>\n<ul>\n<li>props 传入时</li>\n<li>state 变化时</li>\n<li>foreUpdate 调用时</li>\n</ul>\n</li>\n<li>\n<p>反模式</p>\n<ul>\n<li>复制 props 到 state</li>\n<li>props 变化后修改 state</li>\n</ul>\n</li>\n<li>UNSAGE_componentWilMount</li>\n<li>异步渲染机制下，调用多次</li>\n<li>例如同构场景下，客服端和服务端各执行一次</li>\n<li>render</li>\n<li>执行渲染</li>\n<li>\n<p>纯函数</p>\n<ul>\n<li>不要绑定事件</li>\n<li>不要嗲用 setsate</li>\n</ul>\n</li>\n<li>componentDidMount</li>\n<li>发起网络请求</li>\n</ul>\n</li>\n<li>\n<p>更新阶段</p>\n<ul>\n<li>UNSAFE_componentWillReceiveProps</li>\n<li>被替代</li>\n<li>getDeriveStateFromProps</li>\n<li>同挂在</li>\n<li>shouldComponentUpdate</li>\n<li>是否需要触发新的渲染</li>\n<li>\n<p>渲染触发的最后关卡，性能优化</p>\n<ul>\n<li>PureComponent 的实现</li>\n</ul>\n</li>\n<li>UNSAGE_conponentWillUpdate</li>\n<li>被废弃</li>\n<li>异步更新出现暂停更新的情况</li>\n<li>render</li>\n<li>同挂载</li>\n<li>getSnapshotBeforeUpdate</li>\n<li>配合新的异步渲染机制</li>\n<li>不可使用 setState</li>\n<li>componentDidUpdate</li>\n<li>getSnapshotBeforeUpdate 作为第三个参数使用</li>\n</ul>\n</li>\n<li>\n<p>卸载阶段</p>\n<ul>\n<li>conponentWillUnmount</li>\n<li>解除事件绑定</li>\n<li>取消定时器</li>\n</ul>\n</li>\n<li>职责梳理</li>\n<li>\n<p>重新渲染</p>\n<ul>\n<li>函数组件</li>\n<li>函数组件任何时候都会重新渲染</li>\n<li>React.memo()复用上次的渲染结果</li>\n<li>类组件</li>\n<li>state 变化时</li>\n<li>props 传入时</li>\n<li>PureComponet</li>\n</ul>\n</li>\n<li>\n<p>错误处理</p>\n<ul>\n<li>页面白屏</li>\n<li>componentDidCatch 捕获错位</li>\n<li>错误边界</li>\n</ul>\n</li>\n<li>追问</li>\n<li>请求应该放在那里</li>\n</ul>\n</li>\n<li>\n<p>➕➕➕04 类组件和函数组件的区别？</p>\n<ul>\n<li>共同点</li>\n<li>使用方式一致</li>\n<li>表达效果一致（性能，UI）</li>\n<li>不同点</li>\n<li>\n<p>心智模型</p>\n<ul>\n<li>OOP</li>\n<li>FP</li>\n</ul>\n</li>\n<li>\n<p>使用场景</p>\n<ul>\n<li>生命周期</li>\n<li>设计模式：继承</li>\n</ul>\n</li>\n<li>\n<p>性能优化</p>\n<ul>\n<li>shouldComponentUpdate</li>\n<li>React.memo</li>\n</ul>\n</li>\n<li>\n<p>Hooks</p>\n<ul>\n<li>淡出生命周期，取代类</li>\n<li>组合优于继承</li>\n<li>简单</li>\n<li>易复用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕05 如何设计 React 组件？</p>\n<ul>\n<li>(背景：如何将组件更好的组合 --- 缺乏一种设计模式)</li>\n<li>如何组合</li>\n<li>不同场景吗，组合方式是不一样的</li>\n<li>设计模式（经典分类）</li>\n<li>\n<p>无状态组件（展示组件）：只做展示，通用行强，复用性好</p>\n<ul>\n<li>（均是关注点分离的应用）</li>\n<li>代理组件</li>\n<li>内聚 props ，封装分层</li>\n<li>样式组件</li>\n<li>内聚样式</li>\n<li>布局组件</li>\n<li>内聚布局</li>\n<li>性能优化</li>\n</ul>\n</li>\n<li>\n<p>有状态组件（灵巧组件）：处理业务逻辑和状态（组合组件），注重业务本身</p>\n<ul>\n<li>容器组件</li>\n<li>拉取数据</li>\n<li>组合组件</li>\n<li>（关注点分离）</li>\n<li>高阶组件</li>\n<li>（装饰器写法 - 装饰器模式）</li>\n<li>\n<p>抽取公共逻辑</p>\n<ul>\n<li>登录态校验</li>\n<li>页面埋点</li>\n</ul>\n</li>\n<li>链式调用</li>\n<li>渲染劫持</li>\n<li>\n<p>缺陷</p>\n<ul>\n<li>丢失静态函数</li>\n<li>refs 属性不能透传</li>\n<li>React.forwordRef</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>工程化实践</li>\n<li>目录结构划分</li>\n<li>引入工程管理</li>\n</ul>\n</li>\n<li>\n<p>➕06 setState 是同步更新还是异步更新？</p>\n<ul>\n<li>（不同场景下不同）</li>\n<li>控制点</li>\n<li>非真异步</li>\n<li>\n<p>isBatchUpdate => lanes</p>\n<ul>\n<li>setState 先存入 state 队列</li>\n<li>isBatchUpdte == true 执行异步操作</li>\n<li>isBatchUpate == false 执行同步操作</li>\n</ul>\n</li>\n<li>异步场景</li>\n<li>React 生命周期函数中</li>\n<li>React 合成事件中</li>\n<li>同步场景</li>\n<li>\n<p>原生事件</p>\n<ul>\n<li>addEventListener</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n</ul>\n</li>\n<li>原因</li>\n<li>保持内部一致性，props</li>\n<li>并发更新，提升性能</li>\n</ul>\n</li>\n<li>\n<p>➕➕07 组件间如何通信？</p>\n<ul>\n<li>（组件树的层级关系，一层，多层）</li>\n<li>一层</li>\n<li>\n<p>父与子</p>\n<ul>\n<li>props 透传（经典设计）</li>\n<li>场景</li>\n<li>初始化默认值</li>\n<li>无状态组件（展示组件）</li>\n</ul>\n</li>\n<li>\n<p>子与父</p>\n<ul>\n<li>回调函数</li>\n<li>场景</li>\n<li>函数作为值传递给子组件</li>\n<li>\n<p>renderProps()：react-router v5</p>\n<ul>\n<li>父组件专注于渲染结果</li>\n<li>子组件专注于渲染逻辑</li>\n</ul>\n</li>\n<li>实例函数</li>\n<li>场景</li>\n<li>React Ref 获取子组件的实例</li>\n</ul>\n</li>\n<li>\n<p>兄弟组件</p>\n<ul>\n<li>共同的父节点进行中转</li>\n<li>场景</li>\n<li>容器组件中协调各组件</li>\n</ul>\n</li>\n<li>多层</li>\n<li>嵌套层次太深，无直接联系</li>\n<li>\n<p>方案</p>\n<ul>\n<li>context</li>\n<li>\n<p>场景</p>\n<ul>\n<li>国际化</li>\n</ul>\n</li>\n<li>全局变量</li>\n<li>临时存储值</li>\n<li>全局事件</li>\n<li>document 的自定义事件，放在 componetDidMount 中</li>\n<li>时序依赖</li>\n<li>状态管理框架</li>\n<li>成本高</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕➕08 列举 React 状态管理库？</p>\n<ul>\n<li>（背景：横跨多个层级共享状态）</li>\n<li>（context 的缺点：难以追溯数据源，提升耦合度，难以复用和测试）</li>\n<li>flux</li>\n<li>\n<p>单向数据流动<img src=\"https://cdn.nlark.com/yuque/0/2022/png/377147/1649744054594-89def2f5-7c1c-4710-b986-6e3ba955eed3.png#clientId=ubfed43c7-cbb4-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=uaf97b044&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=616&#x26;originWidth=1244&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=65921&#x26;status=done&#x26;style=none&#x26;taskId=ub1ea1c01-d066-4665-9abd-0be420211d7&#x26;title=#crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;id=BBTSi&#x26;originHeight=616&#x26;originWidth=1244&#x26;originalType=binary&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;status=done&#x26;style=none&#x26;title=\" alt=\"image.png\"></p>\n<ul>\n<li>view 视图层：react 组件</li>\n<li>store 数据层：维护数据，和数据处理逻辑</li>\n<li>dispatcher 管理数据流动的中央枢纽</li>\n<li>action：事件通知通过 type 标记</li>\n</ul>\n</li>\n<li>\n<p>优点</p>\n<ul>\n<li>解决 MVC 中数据流不清晰的问题，分工明确</li>\n<li>大型项目容易管理和维护</li>\n</ul>\n</li>\n<li>redux</li>\n<li>\n<p>三大原则（深受函数式编程的影响）</p>\n<ul>\n<li>单一数据源：应用的数据源存储在一颗 object tree 中，并且只存在唯一一个 store</li>\n<li>纯函数 reducer：描述 action 如何改变状态树</li>\n<li>state 只读：改变 state 的唯一办法就是触发 action</li>\n</ul>\n</li>\n<li>\n<p>导致</p>\n<ul>\n<li>所有事件都收拢 action 去触发</li>\n<li>所有 UI 状态都交给 store 去管理</li>\n<li>所有的业务逻辑都交给 reducer 去处理</li>\n</ul>\n</li>\n<li>三大原则实现了时间回溯功能（）</li>\n<li>\n<p>副作用</p>\n<ul>\n<li>action ，refucer 都是纯函数，store 只是一个 state 状态树，都不能完成副作用的操作</li>\n<li>方案</li>\n<li>\n<p>在 dispatch 的时候添加中间件，拦截分发的 action 添加额外的复杂行为（副作用等）</p>\n<ul>\n<li>redux-thunk</li>\n<li>redux-sage</li>\n<li>redux-promise</li>\n</ul>\n</li>\n<li>\n<p>在 reducer 中直接处理副作用</p>\n<ul>\n<li>redux-loop</li>\n</ul>\n</li>\n<li>\n<p>大而全的方案</p>\n<ul>\n<li>rematch</li>\n<li>dva</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>优点</p>\n<ul>\n<li>可预测，易测试</li>\n<li>代码结构严谨，易维护</li>\n<li>生态丰富</li>\n</ul>\n</li>\n<li>mobx</li>\n<li>监听数据属性的变化，直接在数据上更改来触发 UI 渲染</li>\n<li>mobx5 实现监听的方式采用 Object.defineProperty</li>\n<li>mobx5 之后采用 Proxy</li>\n<li>追问</li>\n<li>实现 redux</li>\n<li>实现 redux-thunk</li>\n</ul>\n</li>\n<li>\n<p>09 Virtual DOM 的工作原理是什么？</p>\n<ul>\n<li>是什么？（干嘛的，用途）</li>\n<li>虚拟 dom 是对真实 dom 的高度抽象</li>\n<li>设计初期为避免大量的 DOM 操作和降低代码整体的风险而引入</li>\n<li>设计思路（实现）</li>\n<li>render 函数中的 jsx 会被编译为 React.createElement</li>\n<li>React.createElement 返回一个 Plain Object 包含 type tage props chrend 等属性</li>\n<li>Plain Objec 通过属性结构构成一颗虚拟 dom</li>\n<li>当状态变化时，将前后虚拟 dom 进行对比（diff 算法），生成的结果为 patch</li>\n<li>渲染 path 完成对真实 dom 的操作</li>\n<li>优缺点</li>\n<li>\n<p>优点</p>\n<ul>\n<li>改善大规模 DOM 操作的性能</li>\n<li>规避 xss 风险</li>\n<li>低成本跨平台开发</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>内存占有高</li>\n<li>高性能场景难以优化（google earth）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>10 React diff 算法有何不同？</p>\n<ul>\n<li>是什么？（干嘛的，用途）</li>\n<li>通过对比新旧两颗虚拟 DOM 的变更差异，将更新补丁作用于真实 dom；</li>\n<li>以最小成本更新视图</li>\n<li>过程：触发更新 =》生成补丁 =》 应用补丁</li>\n<li>设计思路（实现）</li>\n<li>\n<p>更新时机</p>\n<ul>\n<li>state 变化</li>\n</ul>\n</li>\n<li>遍历算法（深度优先）</li>\n<li>\n<p>优化策略（分治）</p>\n<ul>\n<li>树对比</li>\n<li>只对同层对比</li>\n<li>组件对比</li>\n<li>同一类型则进行树对比，不是则直接放入补丁中</li>\n<li>元素对比</li>\n<li>同层级元素，通过 key 标记操作生成补丁</li>\n</ul>\n</li>\n<li>\n<p>fiber 架构</p>\n<ul>\n<li>节点和树采用了 fiberNode 和 fiberTree 重构</li>\n<li>fiberNode 使用了双链表</li>\n<li>跟新过程由 current 和 workProgress 两颗树完成双缓存</li>\n</ul>\n</li>\n<li>\n<p>对比</p>\n<ul>\n<li>preact</li>\n<li>整体设计相似</li>\n<li>没有 fiber</li>\n<li>底层采用真实 dom 对比</li>\n<li>vue</li>\n<li>整体设计相似</li>\n<li>没有 fiber</li>\n</ul>\n</li>\n<li>优缺点</li>\n<li>可中断更新</li>\n<li>时间切片</li>\n<li>追问：根据 diff 如何优化代码</li>\n<li>避免跨层级节点移动</li>\n<li>尽量减少组件层级深度</li>\n<li>设置唯一 key 优化</li>\n<li>设置 shouldComponentUpdate 或者 React.PureComponet 减少 diff 次数</li>\n</ul>\n</li>\n<li>\n<p>➕➕➕11 如何解释 React 的渲染流程？</p>\n<ul>\n<li>（渲染过程大致相同，但协调不同，以 v16 为界 分为 stack reconciler 和 fiber reconciler）</li>\n<li>15.x</li>\n<li>\n<p>核心：</p>\n<ul>\n<li>stack reconciler 调度方式</li>\n</ul>\n</li>\n<li>\n<p>调度</p>\n<ul>\n<li>递归</li>\n</ul>\n</li>\n<li>\n<p>阶段</p>\n<ul>\n<li>挂载</li>\n<li>ReactMount 模块完成</li>\n<li>更新</li>\n<li>ReactUpdate 模块完成</li>\n<li>卸载</li>\n</ul>\n</li>\n<li>\n<p>事务（基本处理单位）</p>\n<ul>\n<li>优点</li>\n<li>原子性（不可再分）</li>\n<li>隔离性</li>\n<li>一致性</li>\n<li>作用</li>\n<li>链接 react 和虚拟 dom 处理挂载、更新、和卸载等逻辑</li>\n</ul>\n</li>\n<li>16.x</li>\n<li>\n<p>核心：</p>\n<ul>\n<li>fiber reconciler 调度方式</li>\n</ul>\n</li>\n<li>\n<p>调度</p>\n<ul>\n<li>协作式多任务模式</li>\n<li>requestIdleCallback</li>\n<li>优先级策略</li>\n<li>标记 tag</li>\n</ul>\n</li>\n<li>\n<p>阶段</p>\n<ul>\n<li>render</li>\n<li>\n<p>fiber</p>\n<ul>\n<li>基于 React Element 的二次封装</li>\n<li>提供父子兄节点的引用=》双向链表</li>\n</ul>\n</li>\n<li>可终端，可停止，无副作用</li>\n<li>\n<p>work</p>\n<ul>\n<li>requestIdleCallback</li>\n<li>优先级</li>\n<li>workInProgress</li>\n</ul>\n</li>\n<li>双缓存树</li>\n<li>commit</li>\n<li>更新 dom 执行副作用</li>\n<li>同步更新（不可中断）</li>\n</ul>\n</li>\n<li>\n<p>优势</p>\n<ul>\n<li>提高 react 在动画画布以及手势下的性能表现</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>12 React 渲染异常会造成什么样的结果？</p>\n<ul>\n<li>是什么？</li>\n<li>\n<p>现象</p>\n<ul>\n<li>页面白屏</li>\n</ul>\n</li>\n<li>\n<p>原理</p>\n<ul>\n<li>渲染层，空安全</li>\n</ul>\n</li>\n<li>怎么解决</li>\n<li>\n<p>工程化：</p>\n<ul>\n<li>通用方案</li>\n<li>\n<p>预防</p>\n<ul>\n<li>引入外部函数</li>\n<li>idx</li>\n<li>lodash.get</li>\n<li>bable 插件</li>\n<li>可选链操作符</li>\n<li>使用 typescript</li>\n<li>3.7 以上使用可选链操作符</li>\n</ul>\n</li>\n<li>\n<p>兜底</p>\n<ul>\n<li>高阶函数</li>\n<li>npm 包</li>\n</ul>\n</li>\n<li>量化结果</li>\n<li>\n<p>覆盖率</p>\n<ul>\n<li>团队项目 100%</li>\n</ul>\n</li>\n<li>统计数</li>\n<li>线上报警</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕13 如何分析和调优性能瓶颈？</p>\n<ul>\n<li>建立衡量指标</li>\n<li>\n<p>指标</p>\n<ul>\n<li>FCP</li>\n<li>TTI</li>\n<li>Page Load</li>\n<li>FPS</li>\n<li>静态资源及 API 请求成功率</li>\n</ul>\n</li>\n<li>\n<p>采集</p>\n<ul>\n<li>lightihouse</li>\n</ul>\n</li>\n<li>确认优化原因</li>\n<li>\n<p>业务场景划分</p>\n<ul>\n<li>2C</li>\n<li>管理后台</li>\n<li>，，，</li>\n</ul>\n</li>\n<li>\n<p>以用户比例划分</p>\n<ul>\n<li>tp50</li>\n<li>tp99</li>\n</ul>\n</li>\n<li>实施方案过程</li>\n<li>Loading 图标</li>\n<li>骨架屏</li>\n<li>异步加载</li>\n<li>懒加载</li>\n<li>CDN</li>\n<li>Https</li>\n<li>\n<p>React</p>\n<ul>\n<li>长列表</li>\n<li>重渲染</li>\n</ul>\n</li>\n<li>计算效果收益</li>\n<li>\n<p>数据</p>\n<ul>\n<li>技术服务于业务</li>\n<li>业务指标指导优化</li>\n</ul>\n</li>\n<li>\n<p>效果</p>\n<ul>\n<li>tp50</li>\n<li>tp99</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕14 如何避免重复渲染？</p>\n<ul>\n<li>优化时机</li>\n<li>业务标准</li>\n<li>数据支撑</li>\n<li>定位方式</li>\n<li>复现</li>\n<li>\n<p>工具</p>\n<ul>\n<li>Preformance</li>\n<li>React Profiler</li>\n</ul>\n</li>\n<li>常见的坑</li>\n<li>\n<p>参数动态变化，使 PureComponent 和 Reat.memo 破防</p>\n<ul>\n<li>jsx 属性使用箭头函数</li>\n<li>每次都产生新的对象</li>\n</ul>\n</li>\n<li>处理方案</li>\n<li>\n<p>缓存</p>\n<ul>\n<li>reselect 避免产生新的对象</li>\n</ul>\n</li>\n<li>\n<p>不可变数据</p>\n<ul>\n<li>ImmutableJS</li>\n<li>immerjs</li>\n</ul>\n</li>\n<li>\n<p>手动控制</p>\n<ul>\n<li>shuldComponetUpdate</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>15 如何提升 React 代码的可维护性？</p>\n<ul>\n<li>（潜台词，项目的可维护性）</li>\n<li>角度</li>\n<li>软件工程（工程化）</li>\n<li>维度</li>\n<li>\n<p>可分析性</p>\n<ul>\n<li>目标</li>\n<li>快速定位线上问题</li>\n<li>预防</li>\n<li>人工 code review</li>\n<li>lint 工具校验</li>\n<li>兜底</li>\n<li>souremap 定位</li>\n</ul>\n</li>\n<li>\n<p>可改变性</p>\n<ul>\n<li>目标</li>\n<li>易于扩展，易于迭代</li>\n<li>设计模式</li>\n<li>组件的设计模式</li>\n<li>架构设计</li>\n<li>状态管理框架</li>\n</ul>\n</li>\n<li>\n<p>稳定性</p>\n<ul>\n<li>目标</li>\n<li>避免修改代码引起线上不必要问题</li>\n<li>措施</li>\n<li>核心业务单元测试</li>\n</ul>\n</li>\n<li>\n<p>易测试性</p>\n<ul>\n<li>目标</li>\n<li>易于发现代码潜在的问题</li>\n<li>架构划分</li>\n<li>纯函数</li>\n</ul>\n</li>\n<li>\n<p>可维护性</p>\n<ul>\n<li>遵守约定，提升代码的可读性</li>\n<li>减少人为因素，加强工具干涉</li>\n<li>eslint</li>\n<li>stylelint</li>\n<li>commitlint</li>\n<li>editorconfig</li>\n<li>prettier</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕➕16 React Hooks 使用限制有哪些？</p>\n<ul>\n<li>是什么？</li>\n<li>\n<p>列举限制</p>\n<ul>\n<li>不要再循环，条件，嵌套函数中调用 Hook</li>\n<li>在 React 函数组件中使用 Hook</li>\n</ul>\n</li>\n<li>为什么？</li>\n<li>\n<p>设计初衷</p>\n<ul>\n<li>改进 React 组件开发模式</li>\n</ul>\n</li>\n<li>\n<p>问题领域</p>\n<ul>\n<li>组件难以复用状态逻辑</li>\n<li>（常见解决方案）</li>\n<li>高阶函数</li>\n<li>render props</li>\n<li>状态管理框架</li>\n<li>复杂的组件难以理解</li>\n<li>生命周期函数与业务逻辑耦合，导致组件关联部分难以差分</li>\n<li>人和机器都容易混淆类</li>\n<li>\n<p>this 问题</p>\n<ul>\n<li>值捕获问题</li>\n<li>类属性草案</li>\n</ul>\n</li>\n<li>编译优化</li>\n</ul>\n</li>\n<li>\n<p>方案原理</p>\n<ul>\n<li>not magic just array</li>\n</ul>\n</li>\n<li>怎么做？</li>\n<li>\n<p>如何规避</p>\n<ul>\n<li>Eslint</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕17 useEffect 和 useLayoutEffect 的区别在那里？</p>\n<ul>\n<li>共同点</li>\n<li>\n<p>使用方式</p>\n<ul>\n<li>函数签名一致</li>\n<li>底层都是调用 mountEffectImpl</li>\n</ul>\n</li>\n<li>\n<p>运用效果</p>\n<ul>\n<li>处理副作用</li>\n</ul>\n</li>\n<li>不同点</li>\n<li>\n<p>使用场景</p>\n<ul>\n<li>Effect：绝大多数场景</li>\n<li>LayoutEffect：处理 dom 操作，调整样式，避免页面闪烁</li>\n</ul>\n</li>\n<li>\n<p>独有能力</p>\n<ul>\n<li>Effect：异步处理副作用</li>\n<li>LayoutEffect：同步处理副作用</li>\n</ul>\n</li>\n<li>\n<p>设计原理</p>\n<ul>\n<li>Effect：异步调用</li>\n<li>LayoutEffect： 同步调用</li>\n</ul>\n</li>\n<li>\n<p>未来趋势</p>\n<ul>\n<li>暂无变化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>➕➕➕18 谈谈 React Hooks 的设计模式？</p>\n<ul>\n<li>认知基础</li>\n<li>抛弃生命周期，向 effects 思考</li>\n<li>实践心得（规范推广）</li>\n<li>\n<p>React.memo 被 React.useMemo 替代</p>\n<ul>\n<li>React.memo 不能控制组件内部共享状态的变化</li>\n</ul>\n</li>\n<li>\n<p>常量 和 函数声明</p>\n<ul>\n<li>函数组件中每次渲染都会重新声明常量和创建函数（无意义的操作）</li>\n<li>useCallback</li>\n</ul>\n</li>\n<li>\n<p>useEffect 的第二个参数</p>\n<ul>\n<li>不要使用引用类型的数据，推荐使用值类型的数据</li>\n<li>JSON.stringify</li>\n</ul>\n</li>\n<li>外观模式</li>\n<li>\n<p>将业务逻辑封装到各自自定义的 hook 中</p>\n<ul>\n<li>入用户信息操作：获取用户，增加用户，删除用户等</li>\n</ul>\n</li>\n<li>组件内部是抽空的，不放具体的业务逻辑，只去带有 hook 暴露的接口</li>\n<li>有利于测试关键路劲下的业务逻辑</li>\n</ul>\n</li>\n<li>\n<p>19 React Router 的实现原理和工作方式是什么？</p>\n<ul>\n<li>实现原理</li>\n<li>\n<p>外部：基础原理</p>\n<ul>\n<li>Hash</li>\n<li>Path</li>\n<li>\n<p>html5 histroy api</p>\n<ul>\n<li>pushState</li>\n<li>replaceState</li>\n</ul>\n</li>\n<li>historyApiCallback</li>\n</ul>\n</li>\n<li>\n<p>内部：实践方案</p>\n<ul>\n<li>history 库</li>\n<li>跨平台兼容</li>\n<li>\n<p>内存路由</p>\n<ul>\n<li>react-router-native</li>\n</ul>\n</li>\n<li>\n<p>浏览器路由</p>\n<ul>\n<li>react-router-dom</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>工作方式</li>\n<li>\n<p>整体：设计模式</p>\n<ul>\n<li>Monorepo</li>\n<li>Context</li>\n</ul>\n</li>\n<li>\n<p>局部：关键模块</p>\n<ul>\n<li>Context 容器</li>\n<li>Router</li>\n<li>MemoryRouter</li>\n<li>直接消费者，匹配路由</li>\n<li>Route</li>\n<li>Redirect</li>\n<li>Switch</li>\n<li>。。。</li>\n<li>与平台关联的功能组件</li>\n<li>Link</li>\n<li>NavLink</li>\n<li>DeepLinking</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>20 React 中常用库有哪些？</p>\n<ul>\n<li>（从开发流程切入）</li>\n<li>初始化</li>\n<li>\n<p>create-react-app</p>\n<ul>\n<li>创建工程</li>\n<li>react-app-rewired 配置</li>\n</ul>\n</li>\n<li>vite</li>\n<li>\n<p>dva</p>\n<ul>\n<li>一站式方案</li>\n</ul>\n</li>\n<li>\n<p>umi</p>\n<ul>\n<li>一站式方案</li>\n</ul>\n</li>\n<li>\n<p>create-react-libray</p>\n<ul>\n<li>创建库</li>\n</ul>\n</li>\n<li>\n<p>storybook</p>\n<ul>\n<li>维护大规模组件</li>\n</ul>\n</li>\n<li>开发</li>\n<li>\n<p>路由</p>\n<ul>\n<li>react-router</li>\n</ul>\n</li>\n<li>\n<p>样式</p>\n<ul>\n<li>css module</li>\n<li>css-loader</li>\n<li>css-in-js</li>\n<li>emotion</li>\n<li>styled-component</li>\n</ul>\n</li>\n<li>\n<p>组件库</p>\n<ul>\n<li>antd</li>\n</ul>\n</li>\n<li>\n<p>功能组件</p>\n<ul>\n<li>拖拽</li>\n<li>reacnt-dnd</li>\n<li>react-draggable</li>\n<li>预览 pdf</li>\n<li>react-pdf-view</li>\n<li>视频播放</li>\n<li>video-react</li>\n<li>长列表</li>\n<li>react-window</li>\n<li>react-virtualized</li>\n</ul>\n</li>\n<li>\n<p>状态管理</p>\n<ul>\n<li>redux</li>\n<li>mobx</li>\n</ul>\n</li>\n<li>构建</li>\n<li>webpack</li>\n<li>rullup</li>\n<li>esbuild</li>\n<li>检查</li>\n<li>\n<p>代码规范检查</p>\n<ul>\n<li>eslint</li>\n</ul>\n</li>\n<li>\n<p>测试</p>\n<ul>\n<li>jest</li>\n<li>enzme</li>\n<li>react-testing-library</li>\n<li>react-hooks-testing-library</li>\n</ul>\n</li>\n<li>发布</li>\n<li>s3-pluging-webpack</li>\n</ul>\n</li>\n<li>➕ 21 useEffect / useMemo 的区别？</li>\n</ul>\n<h2>玖、综合场景</h2>\n<ul>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e5%a4%9a%e5%9b%be%e7%ab%99%e7%82%b9%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">多图站点性能优化 🔥🔥🔥</a></p>\n<ul>\n<li>图片优化</li>\n<li>合适的图片格式</li>\n<li>压缩和缩放图片</li>\n<li>网络传输优化</li>\n<li>\n<p>开启 http/2</p>\n<ul>\n<li>使用精灵图 / 雪碧图，减少 HTTP 请求数。</li>\n<li>10kb 大小以内的图片资源使用 base64 编码，减少 HTTP 请求数。</li>\n<li>通过使用多个域名，开启多个 TCP 连接，突破浏览器同源最大并发连接数的限制。</li>\n</ul>\n</li>\n<li>使用 cdn</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%9b%be%e7%89%87%e5%8a%a0%e8%bd%bd%e7%ad%96%e7%95%a5%e4%bc%98%e5%8c%96\">图片加载策略优化</a></li>\n<li>\n<p>懒加载</p>\n<ul>\n<li>懒加载的策略是推迟加载离屏图片资源，从而减少资源请求数。实现懒加载的主流方案有：</li>\n<li>使用 img 标签的 loading 属性。</li>\n<li>使用 Intersection Observer API。</li>\n<li>使用 scroll、resize 和 orientationchange 事件</li>\n</ul>\n</li>\n<li>预加载</li>\n</ul>\n</li>\n<li>\n<p>➕➕<a href=\"https://interview.shanejix.com/#/?id=%e5%a6%82%e4%bd%95%e5%87%8f%e5%b0%91%e7%99%bd%e5%b1%8f%e7%9a%84%e6%97%b6%e9%97%b4-%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5\">如何减少白屏的时间 🔥🔥🔥</a></p>\n<ul>\n<li>分析页面打开过程以及可优化的方向：</li>\n<li>\n<p>前置条件</p>\n<ul>\n<li>性能监控指标</li>\n</ul>\n</li>\n<li>\n<p>DNS 解析</p>\n<ul>\n<li>预解析</li>\n<li>域名收敛</li>\n</ul>\n</li>\n<li>\n<p>TCP 连接</p>\n<ul>\n<li>预连接</li>\n</ul>\n</li>\n<li>\n<p>请求优化</p>\n<ul>\n<li>HTTP/2</li>\n</ul>\n</li>\n<li>\n<p>页面解析优化</p>\n<ul>\n<li>服务端渲染</li>\n<li>预渲染</li>\n</ul>\n</li>\n<li>\n<p>资源加载和页面渲染</p>\n<ul>\n<li>骨架屏</li>\n<li>静态资源优化</li>\n<li>\n<p>减小资源大小</p>\n<ul>\n<li>Gzip 压缩文件</li>\n<li>JS 文件拆分，动态加载</li>\n</ul>\n</li>\n<li>\n<p>加快资源加载速度</p>\n<ul>\n<li>CDN（Content Delivery Network）</li>\n<li>HTTP/2</li>\n</ul>\n</li>\n<li>资源预加载</li>\n<li>prefetch</li>\n<li>preload</li>\n<li>quicklink</li>\n</ul>\n</li>\n<li>\n<p>接口请求优化</p>\n<ul>\n<li>接口合并</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://interview.shanejix.com/#/?id=%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e5%85%83%e7%b4%a0%e6%98%af%e5%90%a6%e5%9c%a8%e5%8f%af%e8%a7%86%e5%8c%ba%e5%9f%9f%e4%b8%ad%ef%bc%9f%f0%9f%94%a5%f0%9f%94%a5\">如何判断一个元素是否在可视区域中？🔥🔥</a></p>\n<ul>\n<li><a href=\"https://interview.shanejix.com/#/?id=offsettop%e3%80%81scrolltop\">offsetTop、scrollTop</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=getboundingclientrect\">getBoundingClientRect</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=intersection-observer\">Intersection Observer</a></li>\n</ul>\n</li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%a4%a7%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e5%a6%82%e4%bd%95%e5%81%9a%e6%96%ad%e7%82%b9%e7%bb%ad%e4%bc%a0%ef%bc%9f%f0%9f%94%a5\">大文件上传如何做断点续传？🔥</a></li>\n<li>\n<p>➕ 注册功能前端到后端数据库这一套流程 🔥🔥🔥</p>\n<ul>\n<li><a href=\"https://www.nowcoder.com/tutorial/96/4d6a2fe5345c46458d6727ef78b0f687\">【前端工程师面试宝典】学习说明<em>互联网校招面试真题面经汇总</em>牛客网 (nowcoder.com)</a></li>\n</ul>\n</li>\n<li>\n<p>➕npm 包发版</p>\n<ul>\n<li>major.minor.patch</li>\n<li>^：匹配最近的 minor</li>\n<li>~：匹配最近的 patch</li>\n<li>*：最新的版本</li>\n</ul>\n</li>\n<li>➕ 长列表渲染</li>\n<li>➕➕➕ 组件库的设计全量导入和按需引入的实现</li>\n<li>➕ 轮播的实现</li>\n</ul>\n<h2>拾、数据结构和算法</h2>\n<ul>\n<li>\n<p>➕➕➕ 手撕 code</p>\n<ul>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%b0%be%e9%80%92%e5%bd%92-%f0%9f%94%a5%f0%9f%94%a5\">尾递归 🔥🔥</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e5%87%bd%e6%95%b0%e7%bc%93%e5%ad%98-%f0%9f%94%a5%f0%9f%94%a5\">函数缓存 🔥🔥</a></li>\n<li><a href=\"https://interview.shanejix.com/#/?id=%e4%b8%8a%e6%8b%89%e5%8a%a0%e8%bd%bd-%f0%9f%94%a5\">上拉加载 🔥</a></li>\n<li>高频手撕</li>\n<li><a href=\"https://www.shanejix.com/posts/%E6%89%8B%E6%92%95%20JavaScript%20%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%BD%BB%E5%BA%95%E5%BE%81%E6%9C%8D%E9%9D%A2%E8%AF%95%E5%AE%98/\">https://www.shanejix.com/posts/%E6%89%8B%E6%92%95%20JavaScript%20%E9%AB%98%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%BD%BB%E5%BA%95%E5%BE%81%E6%9C%8D%E9%9D%A2%E8%AF%95%E5%AE%98/</a></li>\n</ul>\n</li>\n<li>\n<p>➕leetcode</p>\n<ul>\n<li>top100</li>\n<li>分类刷题</li>\n<li>目标公司突击</li>\n<li><a href=\"https://github.com/shanejix/algorithm-and-data-structure\">shanejix/algorithm-and-data-structure: Self-learning data structure and algorithm (github.com)</a></li>\n</ul>\n</li>\n</ul>\n<h2>佰、设计模式</h2>\n<ul>\n<li>\n<p>➕➕ 为什么要用工厂方法？</p>\n<ul>\n<li>解耦（关注点分离）</li>\n<li>不关心如何实例化对象</li>\n<li>只关心如何使用</li>\n<li>封装</li>\n<li>不知道具体内部实例细节</li>\n</ul>\n</li>\n<li>➕ 发布订阅</li>\n<li>单例模式</li>\n<li>➕➕➕ 装饰器模式</li>\n<li>代理模式</li>\n</ul>\n<h2>仟、技术之外</h2>\n<ul>\n<li>➕➕➕ 职业规划</li>\n<li>➕ 怎么评价你</li>\n</ul>\n<blockquote>\n<p>作者：<a href=\"https://www.shanejix.com/\">shanejix</a>\n出处：<a href=\"https://www.shanejix.com/posts/2022%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/\">https://www.shanejix.com/posts/2022 金三银四前端面试笔记/</a>\n版权：本作品采用<a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">「署名-非商业性使用-相同方式共享 4.0 国际」</a>许可协议进行许可。\n声明：转载请注明出处！</p>\n</blockquote>","frontmatter":{"title":"2022金三银四前端面试笔记","date":"February 28, 2022","update":"April 12, 2022","url":"https://github.com/shanejix/shanejix.github.io/issues/95"}}},"pageContext":{"slug":"/2022金三银四前端面试笔记/","previous":{"fields":{"slug":"/[Snippet] - EventEmitter/"},"frontmatter":{"title":"[Snippet] - EventEmitter","tags":["Snippet","Pattern"]}},"next":{"fields":{"slug":"/搭建 React 17 源码本地调试环境/"},"frontmatter":{"title":"搭建 React 17 源码本地调试环境","tags":["React"]}}}},"staticQueryHashes":["3159585216","63159454"]}