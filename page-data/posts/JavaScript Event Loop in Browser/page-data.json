{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/JavaScript Event Loop in Browser/","result":{"data":{"site":{"siteMetadata":{"title":"shanejix","description":"learner && coder"}},"allMarkdownRemark":{"edges":[{"node":{"id":"9dd4013c-c308-552c-bd2c-04f0cd996599","timeToRead":5}},{"node":{"id":"d29bf37d-75f0-501e-92b1-42c06cdbcd7b","timeToRead":3}},{"node":{"id":"89619e78-eeef-5342-b7fe-7626ee925f57","timeToRead":9}},{"node":{"id":"cb3a4052-202e-5a46-bf15-4e9b30e34ebf","timeToRead":3}},{"node":{"id":"45c6b07a-fc6a-5800-9907-86a94c1f4ace","timeToRead":2}},{"node":{"id":"db38bc53-9935-56f0-a9e2-0be373990d78","timeToRead":3}},{"node":{"id":"1dcfd849-d044-5c73-b31a-5fd30393f430","timeToRead":14}},{"node":{"id":"7b38ed3c-4032-581a-aab4-bda6dcb8fa78","timeToRead":15}},{"node":{"id":"d15e9143-f799-527d-b71d-2b8fc195817c","timeToRead":12}},{"node":{"id":"ba521381-a518-5686-a682-0ada55a7dd73","timeToRead":4}},{"node":{"id":"ba58ecad-907f-5ad2-bc26-9167d7607dcc","timeToRead":12}},{"node":{"id":"08b71346-abf3-5649-84f5-2f8ae4f48c6a","timeToRead":3}},{"node":{"id":"da55e002-3a8a-5af2-929e-4de7e3a8d314","timeToRead":4}},{"node":{"id":"4e56b6de-c0ca-572e-9f9d-e769592aa49b","timeToRead":2}},{"node":{"id":"af002700-632d-547f-82b9-f31919d4f03e","timeToRead":1}},{"node":{"id":"7b6d671f-8de2-5511-91e9-0797db813dc7","timeToRead":1}},{"node":{"id":"ad4fad45-b734-560c-8324-a9708e1e04c4","timeToRead":1}},{"node":{"id":"ef84ef13-dac8-5cfa-ac69-d0ea44f677f1","timeToRead":2}},{"node":{"id":"69026b7f-ca1c-5eea-8f61-76972396800c","timeToRead":2}},{"node":{"id":"52b13183-db66-5637-bc21-c828b8dabddd","timeToRead":8}},{"node":{"id":"14bde951-d8e7-5045-84f7-dd9479cfafc3","timeToRead":35}},{"node":{"id":"aa4d72c6-d675-52e4-a55b-b07237ed0e1a","timeToRead":2}},{"node":{"id":"eb631c0f-69a5-5ca8-b3c7-1baaed014eea","timeToRead":1}},{"node":{"id":"684d2035-e385-577d-bb53-f7bfca2caa0d","timeToRead":18}},{"node":{"id":"a40d34f8-b202-5f5b-8c33-19c7c163bbce","timeToRead":5}},{"node":{"id":"afc44728-7e4f-5ce3-bf62-373400a8a46a","timeToRead":12}},{"node":{"id":"ca3cc4cf-0ddf-5fb3-a58d-2354b2f0a10e","timeToRead":5}},{"node":{"id":"fe7fd5be-04af-5d1a-b969-f8f4de7db655","timeToRead":1}},{"node":{"id":"fb3bc99d-cf2f-5fbd-981d-1d701815f87b","timeToRead":66}},{"node":{"id":"4de1fb79-73c7-5593-adc3-427351c465e9","timeToRead":101}},{"node":{"id":"9a102758-e412-5f31-8753-54534e8fdb15","timeToRead":1}},{"node":{"id":"a07217e5-4cbe-54e4-9566-2a0df732a1a4","timeToRead":1}},{"node":{"id":"c8a73065-3214-5616-93f3-0df2a119e91d","timeToRead":1}}]},"markdownRemark":{"id":"db38bc53-9935-56f0-a9e2-0be373990d78","excerpt":"同步链接: https://www.shanejix.com/posts/JavaScript Event Loop in Browser/ 浏览器（多进程）其实就是是一个异步非阻塞模型的实现，当新建一个Tab 页面时，就会新开一个进程。一个 Tab…","html":"<blockquote>\n<p>同步链接: <a href=\"https://www.shanejix.com/posts/JavaScript%20Event%20Loop%20in%20Browser/\">https://www.shanejix.com/posts/JavaScript Event Loop in Browser/</a></p>\n</blockquote>\n<p>浏览器（多进程）其实就是是一个<strong>异步非阻塞模型</strong>的实现，当新建一个<strong>Tab 页</strong>面时，就会新开一个<strong>进程</strong>。一个 Tab 页面从加载到渲染需要在<strong>浏览器内核（多线程）</strong>的调度下控制各线程互相配合以保持<strong>同步</strong>。浏览器常驻线程包括：GUI 渲染线程，JavaScript 引擎线程，定时触发器线程，事件触发线程，异步 http 请求线程等。</p>\n<p><strong>虽然 JavaScript 引擎线程时单线程，但是浏览器时内核是多线程，EventLoop 正是浏览器异步非阻塞模型实现的关键，线程通信的桥梁。</strong></p>\n<p>循环阶段：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">   ┌───────────────────────┐\n┌─<span class=\"token operator\">></span>│        script         │\n│  └──────────┬────────────┘\n│             │\n│         microtasts\n│             │\n│           render\n│             │\n│  ┌──────────┴────────────┐\n│  │      mousemove        │\n│  └──────────┬────────────┘\n│             │\n│         microtasts\n│             │\n│           render\n│             │\n│  ┌──────────┴────────────┐\n└──│      setTimeout       │\n   └───────────────────────┘</code></pre></div>\n<p>简化版事件循环算法：</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\"><span class=\"token list punctuation\">1.</span> 从 宏任务 队列（例如 “script”）中出队（dequeue）并执行最早的任务\n\n<span class=\"token list punctuation\">2.</span> 执行所有 微任务：\n\n   <span class=\"token list punctuation\">-</span> 当微任务队列非空时：\n\n   <span class=\"token list punctuation\">-</span> 出队（dequeue）并执行最早的微任务\n\n<span class=\"token list punctuation\">3.</span> 如果有变更，则将变更渲染（render)出来\n\n<span class=\"token list punctuation\">4.</span> 如果宏任务队列为空，则休眠直到出现宏任务\n\n<span class=\"token list punctuation\">5.</span> 转到步骤 1</code></pre></div>\n<p>详细算法流程参见规范：<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\">event-loop-processing-model</a> 动态观察 <code class=\"language-text\">JS Stack</code> ,<code class=\"language-text\">Tasks Queue</code>, <code class=\"language-text\">MicoTasks Queue</code>的详细变化参见：<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">tasks-microtasks</a></p>\n<p>注意点：</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\"><span class=\"token list punctuation\">-</span> 微任务会在上一次宏任务中入队或者在执行微任务队列时入队\n\n<span class=\"token list punctuation\">-</span> 微任务会在执行 [任何其他事件处理，或渲染，或执行任何其他] 宏任务 之前完成(确保了微任务之间的应用程序环境基本相同如没有鼠标坐标更改，没有新的网络数据等)</code></pre></div>\n<p><strong>宏任务</strong>(macrotask，也叫 task)，由宿主（浏览器、Node）发起。如下类型异步任务的回调会进入 <code class=\"language-text\">MacroTask Queue</code>:</p>\n<ul>\n<li>script(整体代码)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate (Node 独有)</li>\n<li>requestAnimationFrame (浏览器独有)</li>\n<li>I/O</li>\n<li>事件队列</li>\n<li>UI rendering (浏览器独有)</li>\n</ul>\n<p><strong>微任务</strong>(microtask,也叫 jobs)，由 JS 自身发起。 如下类型异步任务的回调会进入 <code class=\"language-text\">MicroTask Queue</code>:</p>\n<ul>\n<li>process.nextTick (Node 独有)</li>\n<li>Promise</li>\n<li>async/await（实际就是 promise）</li>\n<li>Object.observe</li>\n<li>MutationObserver(html5 新特性)</li>\n</ul>\n<h2>总结</h2>\n<p>一句话概述什么是事件循环：</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\">在每个宏任务执行末尾，会插入微任务队列（微任务产生于当次宏任务或微任务），然后 pop 出宏任务队列继续执行</code></pre></div>\n<p>EventLoop 不仅仅是靠的 JS 执行线程的单独工作，其背后是浏览器多线程的相互协作和通信</p>\n<h2>references</h2>\n<ul>\n<li><a href=\"https://zh.javascript.info/event-loop\">https://zh.javascript.info/event-loop</a></li>\n<li><a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\">https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model</a></li>\n<li><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></li>\n</ul>\n<blockquote>\n<p>作者：<a href=\"https://www.shanejix.com/\">shanejix</a>\n出处：<a href=\"https://www.shanejix.com/posts/JavaScript%20Event%20Loop%20in%20Browser/\">https://www.shanejix.com/posts/JavaScript Event Loop in Browser/</a>\n版权：本作品采用<a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">「署名-非商业性使用-相同方式共享 4.0 国际」</a>许可协议进行许可。\n声明：转载请注明出处！</p>\n</blockquote>","frontmatter":{"title":"JavaScript Event Loop in Browser","date":"January 14, 2022","update":"April 12, 2022","url":"https://github.com/shanejix/shanejix.github.io/issues/90"}}},"pageContext":{"slug":"/JavaScript Event Loop in Browser/","previous":{"fields":{"slug":"/小米手机欧版MIUI通用卡刷教程/"},"frontmatter":{"title":"小米手机欧版MIUI通用卡刷教程","tags":["Other"]}},"next":{"fields":{"slug":"/Promise 必知必会/"},"frontmatter":{"title":"Promise 必知必会","tags":["JavaScript","Promise"]}}}},"staticQueryHashes":["3159585216","63159454"]}